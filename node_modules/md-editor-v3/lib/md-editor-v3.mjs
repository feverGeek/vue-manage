var Yn = Object.defineProperty;
var Jn = (s, e, t) => e in s ? Yn(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var le = (s, e, t) => (Jn(s, typeof e != "symbol" ? e + "" : e, t), t), Zt = (s, e, t) => {
  if (!e.has(s))
    throw TypeError("Cannot " + t);
};
var a = (s, e, t) => (Zt(s, e, "read from private field"), t ? t.call(s) : e.get(s)), P = (s, e, t) => {
  if (e.has(s))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(s) : e.set(s, t);
}, R = (s, e, t, n) => (Zt(s, e, "write to private field"), n ? n.call(s, t) : e.set(s, t), t), Lt = (s, e, t, n) => ({
  set _(i) {
    R(s, e, i, t);
  },
  get _() {
    return a(s, e, n);
  }
}), I = (s, e, t) => (Zt(s, e, "access private method"), t);
import { reactive as xe, watch as G, onMounted as ie, onBeforeUnmount as Ct, provide as je, computed as ze, ref as ne, defineComponent as ae, createVNode as u, cloneVNode as ei, nextTick as ft, inject as U, Fragment as Kt, toRef as Bt, mergeProps as ti, isVNode as ni } from "vue";
const d = "md-editor", ii = "md-editor-v3", si = "https://at.alicdn.com/t/c/font_2605852_u82y61ve02.js", J = "https://cdnjs.cloudflare.com/ajax/libs", li = `${J}/highlight.js/11.7.0/highlight.min.js`, mn = {
  main: `${J}/prettier/2.8.0/standalone.js`,
  markdown: `${J}/prettier/2.8.0/parser-markdown.js`
}, gn = {
  css: `${J}/cropperjs/1.5.13/cropper.min.css`,
  js: `${J}/cropperjs/1.5.13/cropper.min.js`
}, oi = `${J}/screenfull.js/5.2.0/screenfull.min.js`, Dn = [
  "bold",
  "underline",
  "italic",
  "strikeThrough",
  "-",
  "title",
  "sub",
  "sup",
  "quote",
  "unorderedList",
  "orderedList",
  "task",
  "-",
  "codeRow",
  "code",
  "link",
  "image",
  "table",
  "mermaid",
  "katex",
  "-",
  "revoke",
  "next",
  "save",
  "=",
  "prettier",
  "pageFullscreen",
  "fullscreen",
  "preview",
  "htmlPreview",
  "catalog",
  "github"
], Hn = ["markdownTotal", "=", "scrollSwitch"], pn = {
  "zh-CN": {
    toolbarTips: {
      bold: "加粗",
      underline: "下划线",
      italic: "斜体",
      strikeThrough: "删除线",
      title: "标题",
      sub: "下标",
      sup: "上标",
      quote: "引用",
      unorderedList: "无序列表",
      orderedList: "有序列表",
      task: "任务列表",
      codeRow: "行内代码",
      code: "块级代码",
      link: "链接",
      image: "图片",
      table: "表格",
      mermaid: "mermaid图",
      katex: "katex公式",
      revoke: "后退",
      next: "前进",
      save: "保存",
      prettier: "美化",
      pageFullscreen: "浏览器全屏",
      fullscreen: "屏幕全屏",
      preview: "预览",
      htmlPreview: "html代码预览",
      catalog: "目录",
      github: "源码地址"
    },
    titleItem: {
      h1: "一级标题",
      h2: "二级标题",
      h3: "三级标题",
      h4: "四级标题",
      h5: "五级标题",
      h6: "六级标题"
    },
    imgTitleItem: {
      link: "添加链接",
      upload: "上传图片",
      clip2upload: "裁剪上传"
    },
    linkModalTips: {
      linkTitle: "添加链接",
      imageTitle: "添加图片",
      descLabel: "链接描述：",
      descLabelPlaceHolder: "请输入描述...",
      urlLabel: "链接地址：",
      urlLabelPlaceHolder: "请输入链接...",
      buttonOK: "确定"
    },
    clipModalTips: {
      title: "裁剪图片上传",
      buttonUpload: "上传"
    },
    copyCode: {
      text: "复制代码",
      successTips: "已复制！",
      failTips: "复制失败！"
    },
    mermaid: {
      flow: "流程图",
      sequence: "时序图",
      gantt: "甘特图",
      class: "类图",
      state: "状态图",
      pie: "饼图",
      relationship: "关系图",
      journey: "旅程图"
    },
    katex: {
      inline: "行内公式",
      block: "块级公式"
    },
    footer: {
      markdownTotal: "字数",
      scrollAuto: "同步滚动"
    }
  },
  "en-US": {
    toolbarTips: {
      bold: "bold",
      underline: "underline",
      italic: "italic",
      strikeThrough: "strikeThrough",
      title: "title",
      sub: "subscript",
      sup: "superscript",
      quote: "quote",
      unorderedList: "unordered list",
      orderedList: "ordered list",
      task: "task list",
      codeRow: "inline code",
      code: "block-level code",
      link: "link",
      image: "image",
      table: "table",
      mermaid: "mermaid",
      katex: "formula",
      revoke: "revoke",
      next: "undo revoke",
      save: "save",
      prettier: "prettier",
      pageFullscreen: "fullscreen in page",
      fullscreen: "fullscreen",
      preview: "preview",
      htmlPreview: "html preview",
      catalog: "catalog",
      github: "source code"
    },
    titleItem: {
      h1: "Lv1 Heading",
      h2: "Lv2 Heading",
      h3: "Lv3 Heading",
      h4: "Lv4 Heading",
      h5: "Lv5 Heading",
      h6: "Lv6 Heading"
    },
    imgTitleItem: {
      link: "Add Img Link",
      upload: "Upload Img",
      clip2upload: "Clip Upload"
    },
    linkModalTips: {
      linkTitle: "Add Link",
      imageTitle: "Add Image",
      descLabel: "Desc:",
      descLabelPlaceHolder: "Enter a description...",
      urlLabel: "Link:",
      urlLabelPlaceHolder: "Enter a link...",
      buttonOK: "OK"
    },
    clipModalTips: {
      title: "Crop Image",
      buttonUpload: "Upload"
    },
    copyCode: {
      text: "Copy",
      successTips: "Copied!",
      failTips: "Copy failed!"
    },
    mermaid: {
      flow: "flow",
      sequence: "sequence",
      gantt: "gantt",
      class: "class",
      state: "state",
      pie: "pie",
      relationship: "relationship",
      journey: "journey"
    },
    katex: {
      inline: "inline",
      block: "block"
    },
    footer: {
      markdownTotal: "Word Count",
      scrollAuto: "Scroll Auto"
    }
  }
}, ri = `${J}/mermaid/9.4.0/mermaid.min.js`, Nt = {
  js: `${J}/KaTeX/0.16.3/katex.min.js`,
  css: `${J}/KaTeX/0.16.3/katex.min.css`
}, vn = {
  a11y: {
    light: `${J}/highlight.js/11.7.0/styles/a11y-light.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/a11y-dark.min.css`
  },
  atom: {
    light: `${J}/highlight.js/11.7.0/styles/atom-one-light.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/atom-one-dark.min.css`
  },
  github: {
    light: `${J}/highlight.js/11.7.0/styles/github.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/github-dark.min.css`
  },
  gradient: {
    light: `${J}/highlight.js/11.7.0/styles/gradient-light.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/gradient-dark.min.css`
  },
  kimbie: {
    light: `${J}/highlight.js/11.7.0/styles/kimbie-light.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/kimbie-dark.min.css`
  },
  paraiso: {
    light: `${J}/highlight.js/11.7.0/styles/paraiso-light.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/paraiso-dark.min.css`
  },
  qtcreator: {
    light: `${J}/highlight.js/11.7.0/styles/qtcreator-light.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/qtcreator-dark.min.css`
  },
  stackoverflow: {
    light: `${J}/highlight.js/11.7.0/styles/stackoverflow-light.min.css`,
    dark: `${J}/highlight.js/11.7.0/styles/stackoverflow-dark.min.css`
  }
}, te = {
  markedRenderer: (s) => s,
  markedExtensions: [],
  markedOptions: {},
  editorExtensions: {},
  editorConfig: {}
}, ai = (s) => {
  if (s)
    for (const e in s) {
      const t = s[e];
      t && (te[e] = t);
    }
};
class ci {
  constructor() {
    // 事件池
    le(this, "pools", {});
  }
  // 移除事件监听
  remove(e, t, n) {
    const l = this.pools[e] && this.pools[e][t];
    l && (this.pools[e][t] = l.filter((r) => r !== n));
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(e) {
    this.pools[e] = {};
  }
  // 注册事件监听
  on(e, t) {
    return this.pools[e] || (this.pools[e] = {}), this.pools[e][t.name] || (this.pools[e][t.name] = []), this.pools[e][t.name].push(t.callback), this.pools[e][t.name].includes(t.callback);
  }
  // 触发事件
  emit(e, t, ...n) {
    this.pools[e] || (this.pools[e] = {});
    const l = this.pools[e][t];
    l && l.forEach((r) => {
      try {
        r(...n);
      } catch (o) {
        console.error(`${t} monitor event exception！`, o);
      }
    });
  }
}
const x = new ci(), Pe = (s, e = 0, t = e) => new Promise((n, i) => {
  s.setSelectionRange ? setTimeout(() => {
    s.setSelectionRange(e, t), s.focus(), n(!0);
  }, 0) : (console.error("Can not reset position!"), i());
}), Qt = (s, e, t) => {
  const { deviationStart: n = 0, deviationEnd: i = 0, direct: l = !1, select: r = !1 } = t;
  let o = "";
  if (s.selectionStart || s.selectionStart === 0) {
    const c = s.selectionStart, f = s.selectionEnd || 0, {
      prefixVal: h = s.value.substring(0, c),
      subfixVal: m = s.value.substring(f, s.value.length)
    } = t;
    o = h + e + m, Pe(
      s,
      // 选中值开始位置为设定开始，否者为结束位置
      r ? c + n : c + e.length + i,
      c + e.length + i
    );
  } else
    o += e;
  return l && (s.value = o), o;
}, ui = (s, e = {
  newWindow: !0,
  nofollow: !0
}) => {
  s || console.error("error link!");
  const t = document.createElement("a");
  t.href = s, t.style.display = "none", e.newWindow && (t.target = "_blank"), e.nofollow && (t.rel = "noopener noreferrer"), document.body.appendChild(t), t.click(), document.body.removeChild(t);
}, bn = (s, e) => {
  const t = Gt(() => {
    s.removeEventListener("scroll", n), s.addEventListener("scroll", n), e.removeEventListener("scroll", n), e.addEventListener("scroll", n);
  }, 50), n = (i) => {
    const l = s.clientHeight, r = e.clientHeight, o = s.scrollHeight, c = e.scrollHeight, f = (o - l) / (c - r);
    i.target === s ? (e.removeEventListener("scroll", n), e.scrollTo({
      top: s.scrollTop / f
      // behavior: 'smooth'
    }), t()) : (s.removeEventListener("scroll", n), s.scrollTo({
      top: e.scrollTop * f
      // behavior: 'smooth'
    }), t());
  };
  return [
    () => {
      t().finally(() => {
        s.dispatchEvent(new Event("scroll"));
      });
    },
    () => {
      s.removeEventListener("scroll", n), e.removeEventListener("scroll", n);
    }
  ];
}, di = (s, e = "image.png") => {
  const t = s.split(","), n = t[0].match(/:(.*?);/);
  if (n) {
    const i = n[1], l = atob(t[1]);
    let r = l.length;
    const o = new Uint8Array(r);
    for (; r--; )
      o[r] = l.charCodeAt(r);
    return new File([o], e, { type: i });
  }
  return null;
}, kn = (s) => {
  if (!s.trim())
    return s;
  const e = s.split(`
`), t = ['<span rn-wrapper aria-hidden="true">'];
  return e.forEach(() => {
    t.push("<span></span>");
  }), t.push("</span>"), `<span class="code-block">${s}</span>${t.join("")}`;
}, Gt = (s, e = 200) => {
  let t = 0;
  return (...n) => new Promise((i) => {
    t && (clearTimeout(t), i("cancel")), t = window.setTimeout(() => {
      s.apply(void 0, n), t = 0, i("done");
    }, e);
  });
}, hi = (s, e = 200) => {
  let t = 0, n = null;
  return (...i) => {
    const l = (r) => {
      t === 0 && (t = r), r - t >= e ? (s.apply(void 0, n), n = null, t = 0) : window.requestAnimationFrame(l);
    };
    n === null && window.requestAnimationFrame(l), n = i;
  };
}, yn = (s, e = "$") => {
  const t = s.split(e);
  let n = e, i = "";
  for (let l = 1; l < t.length; l++)
    if (/\\$/.test(t[l]))
      n += t[l] + "$", i += t[l] + "$";
    else {
      n += t[l] + e, i += t[l];
      break;
    }
  return [n, i];
}, fi = (s) => {
  var t;
  return navigator.userAgent.indexOf("Firefox") > -1 ? s.value.substring(s.selectionStart, s.selectionEnd) : ((t = window.getSelection()) == null ? void 0 : t.toString()) || "";
}, mi = (s, e) => {
  const t = s == null ? void 0 : s.getBoundingClientRect();
  if (e === document.documentElement)
    return t.top - e.clientTop;
  const n = e == null ? void 0 : e.getBoundingClientRect();
  return t.top - n.top;
}, gi = (s, e) => {
  const t = { ...s };
  return e.forEach((n) => {
    Reflect.deleteProperty(t, n);
  }), t;
}, pi = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`, wn = (s, e) => {
  const t = (n) => {
    const i = s.parentElement || document.body, l = i.offsetWidth, r = i.offsetHeight, { clientWidth: o } = document.documentElement, { clientHeight: c } = document.documentElement, f = n.offsetX, h = n.offsetY, m = (g) => {
      let $ = g.x + document.body.scrollLeft - document.body.clientLeft - f, b = g.y + document.body.scrollTop - document.body.clientTop - h;
      $ = $ < 1 ? 1 : $ < o - l - 1 ? $ : o - l - 1, b = b < 1 ? 1 : b < c - r - 1 ? b : c - r - 1, e ? e($, b) : (i.style.left = `${$}px`, i.style.top = `${b}px`);
    };
    document.addEventListener("mousemove", m);
    const v = () => {
      document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", v);
    };
    document.addEventListener("mouseup", v);
  };
  return s.addEventListener("mousedown", t), () => {
    s.removeEventListener("mousedown", t);
  };
}, we = (s, e = "") => {
  const t = document.getElementById(s.id), n = (i) => {
    typeof s.onload == "function" && s.onload(i), s.removeEventListener("load", n);
  };
  t ? e !== "" && typeof s.onload == "function" && (Reflect.get(window, e) ? s.dispatchEvent(new Event("load")) : t.addEventListener("load", n)) : (s.addEventListener("load", n), document.head.appendChild(s));
}, vi = Gt((s, e, t) => {
  const n = document.getElementById(s);
  n && n.setAttribute(e, t);
}, 10), Ut = "onSave", rn = "changeCatalogVisible", jn = "changeFullscreen", xn = "pageFullscreenChanged", $n = "fullscreenChanged", Yt = "previewChanged", Sn = "htmlPreviewChanged", Cn = "catalogVisibleChanged", Pn = "textareaFocus", bi = (s, e) => {
  const { editorId: t, noPrettier: n, previewOnly: i } = s, l = xe({
    // 是否已编译成html
    buildFinished: !1,
    // 存储当前最新的html
    html: ""
  }), r = (o) => {
    if (o.target === document.querySelector(`#${s.editorId}-textarea`))
      if (x.emit(t, "selectTextChange"), o.ctrlKey || o.metaKey)
        switch (o.code) {
          case "KeyS": {
            o.shiftKey ? x.emit(t, "replace", "strikeThrough") : (x.emit(t, Ut, s.modelValue), o.preventDefault());
            break;
          }
          case "KeyB": {
            x.emit(t, "replace", "bold"), o.preventDefault();
            break;
          }
          case "KeyU": {
            o.shiftKey ? (x.emit(t, "replace", "unorderedList"), o.preventDefault()) : (x.emit(t, "replace", "underline"), o.preventDefault());
            break;
          }
          case "KeyI": {
            o.shiftKey ? (x.emit(t, "openModals", "image"), o.preventDefault()) : (x.emit(t, "replace", "italic"), o.preventDefault());
            break;
          }
          case "Digit1": {
            x.emit(t, "replace", "h1"), o.preventDefault();
            break;
          }
          case "Digit2": {
            x.emit(t, "replace", "h2"), o.preventDefault();
            break;
          }
          case "Digit3": {
            x.emit(t, "replace", "h3"), o.preventDefault();
            break;
          }
          case "Digit4": {
            x.emit(t, "replace", "h4"), o.preventDefault();
            break;
          }
          case "Digit5": {
            x.emit(t, "replace", "h5"), o.preventDefault();
            break;
          }
          case "Digit6": {
            x.emit(t, "replace", "h6"), o.preventDefault();
            break;
          }
          case "ArrowUp": {
            x.emit(t, "replace", "sup"), o.preventDefault();
            break;
          }
          case "ArrowDown": {
            x.emit(t, "replace", "sub"), o.preventDefault();
            break;
          }
          case "KeyQ": {
            if (o.key === "a") {
              o.target.select();
              return;
            }
            x.emit(t, "replace", "quote"), o.preventDefault();
            break;
          }
          case "KeyA":
            if (o.key === "q") {
              x.emit(t, "replace", "quote"), o.preventDefault();
              break;
            } else
              return;
          case "KeyO": {
            x.emit(t, "replace", "orderedList"), o.preventDefault();
            break;
          }
          case "KeyC": {
            if (o.shiftKey)
              x.emit(t, "replace", "code"), o.preventDefault();
            else if (o.altKey)
              x.emit(t, "replace", "codeRow"), o.preventDefault();
            else {
              o.preventDefault(), x.emit(t, "replace", "ctrlC");
              break;
            }
            break;
          }
          case "KeyL": {
            x.emit(t, "openModals", "link"), o.preventDefault();
            break;
          }
          case "KeyZ": {
            if (o.key === "w")
              return;
            o.shiftKey ? (x.emit(t, "ctrlShiftZ"), o.preventDefault()) : (x.emit(t, "ctrlZ"), o.preventDefault());
            break;
          }
          case "KeyW":
            if (o.key === "z") {
              o.shiftKey ? (x.emit(t, "ctrlShiftZ"), o.preventDefault()) : (x.emit(t, "ctrlZ"), o.preventDefault());
              break;
            } else
              return;
          case "KeyF": {
            o.shiftKey && (n || (x.emit(t, "replace", "prettier"), o.preventDefault()));
            break;
          }
          case "KeyT": {
            o.altKey && o.shiftKey && (x.emit(t, "replace", "table"), o.preventDefault());
            break;
          }
          case "KeyX": {
            x.emit(t, "replace", "ctrlX"), o.preventDefault();
            break;
          }
          case "KeyD": {
            o.preventDefault(), x.emit(t, "replace", "ctrlD");
            break;
          }
        }
      else
        o.code === "Tab" && (o.preventDefault(), o.shiftKey ? x.emit(t, "replace", "shiftTab") : x.emit(t, "replace", "tab"));
  };
  G(
    () => s.modelValue,
    () => {
      l.buildFinished = !1;
    }
  ), ie(() => {
    i || (window.addEventListener("keydown", r), x.on(t, {
      name: "buildFinished",
      callback(o) {
        l.buildFinished = !0, l.html = o;
      }
    }), x.on(t, {
      name: Ut,
      callback() {
        const o = new Promise((c) => {
          if (l.buildFinished)
            c(l.html);
          else {
            const f = (h) => {
              c(h), x.remove(t, "buildFinished", f);
            };
            x.on(t, {
              name: "buildFinished",
              callback: f
            });
          }
        });
        s.onSave ? s.onSave(s.modelValue, o) : e.emit("onSave", s.modelValue, o);
      }
    }));
  }), Ct(() => {
    i || window.removeEventListener("keydown", r);
  });
}, ki = (s) => {
  var l;
  const { editorId: e, previewOnly: t } = s, n = (l = te == null ? void 0 : te.editorExtensions) == null ? void 0 : l.highlight;
  je("editorId", e), je("tabWidth", s.tabWidth), je(
    "theme",
    ze(() => s.theme)
  ), je(
    "highlight",
    ze(() => {
      const r = {
        ...vn,
        ...n == null ? void 0 : n.css
      }, o = s.codeStyleReverse && s.codeStyleReverseList.includes(s.previewTheme) ? "dark" : s.theme;
      return {
        js: (n == null ? void 0 : n.js) || li,
        css: r[s.codeTheme] ? r[s.codeTheme][o] : vn.atom[o]
      };
    })
  ), je("historyLength", s.historyLength), je("previewOnly", t), je("showCodeRowNumber", s.showCodeRowNumber);
  const i = ze(() => {
    var o;
    const r = {
      ...pn,
      ...(o = te == null ? void 0 : te.editorConfig) == null ? void 0 : o.languageUserDefined
    };
    return r[s.language] ? r[s.language] : pn["zh-CN"];
  });
  je("usedLanguageText", i), je(
    "previewTheme",
    ze(() => s.previewTheme)
  );
}, yi = (s) => {
  var f, h, m, v, g, $;
  const { noPrettier: e, previewOnly: t, noIconfont: n, noUploadImg: i } = s, { editorExtensions: l } = te, r = e || !!((h = (f = te.editorExtensions) == null ? void 0 : f.prettier) != null && h.prettierInstance), o = e || !!((v = (m = te.editorExtensions) == null ? void 0 : m.prettier) != null && v.parserMarkdownInstance), c = i || !!(($ = (g = te.editorExtensions) == null ? void 0 : g.cropper) != null && $.instance);
  ie(() => {
    var C, A, M, T;
    const b = document.createElement("script");
    b.src = (l == null ? void 0 : l.iconfont) || si, b.id = `${d}-icon`;
    const k = document.createElement("script"), p = document.createElement("script");
    k.src = ((C = l == null ? void 0 : l.prettier) == null ? void 0 : C.standaloneJs) || mn.main, k.id = `${d}-prettier`, p.src = ((A = l == null ? void 0 : l.prettier) == null ? void 0 : A.parserMarkdownJs) || mn.markdown, p.id = `${d}-prettierMD`;
    const w = document.createElement("link");
    w.rel = "stylesheet", w.href = ((M = l == null ? void 0 : l.cropper) == null ? void 0 : M.css) || gn.css, w.id = `${d}-cropperCss`;
    const S = document.createElement("script");
    S.src = ((T = l == null ? void 0 : l.cropper) == null ? void 0 : T.js) || gn.js, S.id = `${d}-cropper`, n || we(b), t || (c || (we(w), we(S)), r || we(k), o || we(p));
  });
}, wi = (s, e) => {
  const { editorId: t, previewOnly: n } = s, i = xe({
    pageFullscreen: s.pageFullscreen,
    fullscreen: !1,
    preview: s.preview,
    htmlPreview: s.preview ? !1 : s.htmlPreview
  }), l = (c, f) => {
    i[c] = f === void 0 ? !i[c] : f, c === "preview" && i.preview ? i.htmlPreview = !1 : c === "htmlPreview" && i.htmlPreview && (i.preview = !1);
  };
  let r = "";
  const o = () => {
    i.pageFullscreen || i.fullscreen ? document.body.style.overflow = "hidden" : document.body.style.overflow = r;
  };
  return G(() => [i.pageFullscreen, i.fullscreen], o), ie(() => {
    n || x.on(t, {
      name: "uploadImage",
      callback(c, f) {
        const h = (m) => {
          x.emit(t, "replace", "image", {
            desc: "",
            urls: m
          }), f && f();
        };
        s.onUploadImg ? s.onUploadImg(c, h) : e.emit("onUploadImg", c, h);
      }
    }), r = document.body.style.overflow, o();
  }), [i, l];
}, xi = (s) => {
  const { editorId: e } = s, t = ne(!1);
  ie(() => {
    x.on(e, {
      name: rn,
      callback: (i) => {
        i === void 0 ? t.value = !t.value : t.value = i;
      }
    });
  });
  const n = ze(() => !s.toolbarsExclude.includes("catalog") && s.toolbars.includes("catalog"));
  return [t, n];
}, $i = (s, e, t, n, i) => {
  const { editorId: l } = s;
  G(
    () => n.pageFullscreen,
    (o) => {
      x.emit(l, xn, o);
    }
  ), G(
    () => n.fullscreen,
    (o) => {
      x.emit(l, $n, o);
    }
  ), G(
    () => n.preview,
    (o) => {
      x.emit(l, Yt, o);
    }
  ), G(
    () => n.htmlPreview,
    (o) => {
      x.emit(l, Sn, o);
    }
  ), G(t, (o) => {
    x.emit(l, Cn, o);
  });
  const r = {
    on(o, c) {
      switch (o) {
        case "pageFullscreen": {
          x.on(l, {
            name: xn,
            callback(f) {
              c(f);
            }
          });
          break;
        }
        case "fullscreen": {
          x.on(l, {
            name: $n,
            callback(f) {
              c(f);
            }
          });
          break;
        }
        case "preview": {
          x.on(l, {
            name: Yt,
            callback(f) {
              c(f);
            }
          });
          break;
        }
        case "htmlPreview": {
          x.on(l, {
            name: Sn,
            callback(f) {
              c(f);
            }
          });
          break;
        }
        case "catalog": {
          x.on(l, {
            name: Cn,
            callback(f) {
              c(f);
            }
          });
          break;
        }
      }
    },
    togglePageFullscreen(o) {
      i("pageFullscreen", o);
    },
    toggleFullscreen(o) {
      x.emit(l, jn, o);
    },
    togglePreview(o) {
      i("preview", o);
    },
    toggleHtmlPreview(o) {
      i("htmlPreview", o);
    },
    toggleCatalog(o) {
      x.emit(l, rn, o);
    },
    triggerSave() {
      x.emit(l, Ut);
    },
    insert(o) {
      x.emit(l, "replace", "universal", { generate: o });
    },
    focus() {
      x.emit(l, Pn);
    }
  };
  e.expose(r);
};
const Si = /* @__PURE__ */ ae({
  setup() {
    return () => u("div", {
      class: `${d}-divider`
    }, null);
  }
}), _e = ({
  instance: s,
  ctx: e,
  props: t = {}
}, n = "default") => {
  const i = (s == null ? void 0 : s.$slots[n]) || (e == null ? void 0 : e.slots[n]);
  return (i ? i(s) : "") || t[n];
};
const Ci = () => ({
  trigger: {
    type: String,
    default: "hover"
  },
  overlay: {
    type: [String, Object],
    default: ""
  },
  visible: {
    type: Boolean,
    default: !1
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  // 相对滚动的元素选择器
  relative: {
    type: String,
    default: "html"
  }
}), ot = /* @__PURE__ */ ae({
  props: Ci(),
  setup(s, e) {
    const t = `${d}-dropdown-hidden`, n = xe({
      overlayClass: [t],
      overlayStyle: {},
      triggerHover: !1,
      overlayHover: !1
    }), i = ne(), l = ne(), r = () => {
      var S;
      s.trigger === "hover" && (n.triggerHover = !0);
      const m = i.value, v = l.value, g = m.getBoundingClientRect(), $ = m.offsetTop, b = m.offsetLeft, k = g.height, p = g.width, w = ((S = document.querySelector(s.relative)) == null ? void 0 : S.scrollLeft) || 0;
      n.overlayStyle = {
        ...n.overlayStyle,
        top: $ + k + "px",
        left: b - v.offsetWidth / 2 + p / 2 - w + "px"
      }, s.onChange(!0);
    }, o = () => {
      n.overlayHover = !0;
    };
    G(() => s.visible, (m) => {
      m ? n.overlayClass = n.overlayClass.filter((v) => v !== t) : n.overlayClass.push(t);
    });
    const c = (m) => {
      const v = i.value, g = l.value;
      !v.contains(m.target) && !g.contains(m.target) && s.onChange(!1);
    };
    let f = -1;
    const h = (m) => {
      i.value === m.target ? n.triggerHover = !1 : n.overlayHover = !1, clearTimeout(f), f = window.setTimeout(() => {
        !n.overlayHover && !n.triggerHover && s.onChange(!1);
      }, 10);
    };
    return ie(() => {
      s.trigger === "click" ? (i.value.addEventListener("click", r), document.addEventListener("click", c)) : (i.value.addEventListener("mouseenter", r), i.value.addEventListener("mouseleave", h), l.value.addEventListener("mouseenter", o), l.value.addEventListener("mouseleave", h));
    }), Ct(() => {
      s.trigger === "click" ? (i.value.removeEventListener("click", r), document.removeEventListener("click", c)) : (i.value.removeEventListener("mouseenter", r), i.value.removeEventListener("mouseleave", h), l.value.removeEventListener("mouseenter", o), l.value.removeEventListener("mouseleave", h));
    }), () => {
      const m = _e({
        ctx: e
      }), v = _e({
        props: s,
        ctx: e
      }, "overlay"), g = ei(m instanceof Array ? m[0] : m, {
        ref: i
      }), $ = u("div", {
        class: [`${d}-dropdown`, n.overlayClass],
        style: n.overlayStyle,
        ref: l
      }, [u("div", {
        class: `${d}-dropdown-overlay`
      }, [v instanceof Array ? v[0] : v])]);
      return [g, $];
    };
  }
});
const Ti = () => ({
  title: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean,
    default: !1
  },
  width: {
    type: String,
    default: "auto"
  },
  height: {
    type: String,
    default: "auto"
  },
  onClose: {
    type: Function,
    default: () => {
    }
  },
  showAdjust: {
    type: Boolean,
    default: !1
  },
  isFullscreen: {
    type: Boolean,
    default: !1
  },
  onAdjust: {
    type: Function,
    default: () => {
    }
  },
  class: {
    type: String
  }
}), an = /* @__PURE__ */ ae({
  props: Ti(),
  setup(s, e) {
    const t = ne(s.visible), n = ne([`${d}-modal`]), i = ne(), l = ne();
    let r = () => {
    };
    const o = xe({
      initPos: {
        left: "0px",
        top: "0px"
      },
      historyPos: {
        left: "0px",
        top: "0px"
      }
    }), c = ze(() => s.isFullscreen ? {
      width: "100%",
      height: "100%"
    } : {
      width: s.width,
      height: s.height
    });
    return ie(() => {
      r = wn(l.value, (f, h) => {
        o.initPos.left = f + "px", o.initPos.top = h + "px";
      });
    }), Ct(() => {
      r();
    }), G(() => s.isFullscreen, (f) => {
      f ? r() : r = wn(l.value, (h, m) => {
        o.initPos.left = h + "px", o.initPos.top = m + "px";
      });
    }), G(() => s.visible, (f) => {
      f ? (n.value.push("zoom-in"), t.value = f, ft(() => {
        const h = i.value.offsetWidth / 2, m = i.value.offsetHeight / 2, v = document.documentElement.clientWidth / 2, g = document.documentElement.clientHeight / 2;
        o.initPos.left = v - h + "px", o.initPos.top = g - m + "px";
      }), setTimeout(() => {
        n.value = n.value.filter((h) => h !== "zoom-in");
      }, 140)) : (n.value.push("zoom-out"), setTimeout(() => {
        n.value = n.value.filter((h) => h !== "zoom-out"), t.value = f;
      }, 130));
    }), () => {
      const f = _e({
        ctx: e
      }), h = _e({
        props: s,
        ctx: e
      }, "title");
      return u("div", {
        class: [s.class],
        style: {
          display: t.value ? "block" : "none"
        }
      }, [u("div", {
        class: `${d}-modal-mask`,
        onClick: s.onClose
      }, null), u("div", {
        class: n.value,
        style: {
          ...o.initPos,
          ...c.value
        },
        ref: i
      }, [u("div", {
        class: `${d}-modal-header`,
        ref: l
      }, [h || ""]), u("div", {
        class: `${d}-modal-body`
      }, [f]), u("div", {
        class: `${d}-modal-func`
      }, [s.showAdjust && u("div", {
        class: `${d}-modal-adjust`,
        onClick: (m) => {
          m.stopPropagation(), s.isFullscreen ? o.initPos = o.historyPos : (o.historyPos = o.initPos, o.initPos = {
            left: "0",
            top: "0"
          }), s.onAdjust(!s.isFullscreen);
        }
      }, [u("svg", {
        class: `${d}-icon`,
        "aria-hidden": "true"
      }, [u("use", {
        "xlink:href": `#md-editor-icon-${s.isFullscreen ? "suoxiao" : "fangda"}`
      }, null)])]), u("div", {
        class: `${d}-modal-close`,
        onClick: (m) => {
          m.stopPropagation(), s.onClose && s.onClose();
        }
      }, [u("svg", {
        class: `${d}-icon`,
        "aria-hidden": "true"
      }, [u("use", {
        "xlink:href": "#md-editor-icon-close"
      }, null)])])])])]);
    };
  }
}), Ei = () => ({
  type: {
    type: String,
    default: "link"
  },
  visible: {
    type: Boolean,
    default: !1
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
}), zi = /* @__PURE__ */ ae({
  props: Ei(),
  setup(s) {
    const e = U("usedLanguageText"), t = U("editorId"), n = ze(() => {
      var l, r;
      switch (s.type) {
        case "link":
          return (l = e.value.linkModalTips) == null ? void 0 : l.linkTitle;
        case "image":
          return (r = e.value.linkModalTips) == null ? void 0 : r.imageTitle;
        default:
          return "";
      }
    }), i = xe({
      desc: "",
      url: ""
    });
    return G(() => s.visible, (l) => {
      l || setTimeout(() => {
        i.desc = "", i.url = "";
      }, 200);
    }), () => u(an, {
      title: n.value,
      visible: s.visible,
      onClose: s.onCancel
    }, {
      default: () => {
        var l, r, o, c, f;
        return [u("div", {
          class: `${d}-form-item`
        }, [u("label", {
          class: `${d}-label`,
          for: `link-desc-${t}`
        }, [(l = e.value.linkModalTips) == null ? void 0 : l.descLabel]), u("input", {
          placeholder: (r = e.value.linkModalTips) == null ? void 0 : r.descLabelPlaceHolder,
          class: `${d}-input`,
          id: `link-desc-${t}`,
          type: "text",
          value: i.desc,
          onChange: (h) => {
            i.desc = h.target.value;
          },
          autocomplete: "off"
        }, null)]), u("div", {
          class: `${d}-form-item`
        }, [u("label", {
          class: `${d}-label`,
          for: `link-url-${t}`
        }, [(o = e.value.linkModalTips) == null ? void 0 : o.urlLabel]), u("input", {
          placeholder: (c = e.value.linkModalTips) == null ? void 0 : c.urlLabelPlaceHolder,
          class: `${d}-input`,
          id: `link-url-${t}`,
          type: "text",
          value: i.url,
          onChange: (h) => {
            i.url = h.target.value;
          },
          autocomplete: "off"
        }, null)]), u("div", {
          class: `${d}-form-item`
        }, [u("button", {
          class: [`${d}-btn`, `${d}-btn-row`],
          type: "button",
          onClick: () => {
            s.onOk(i), i.desc = "", i.url = "";
          }
        }, [(f = e.value.linkModalTips) == null ? void 0 : f.buttonOK])])];
      }
    });
  }
});
const _i = () => ({
  visible: {
    type: Boolean,
    default: !1
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
}), Ai = /* @__PURE__ */ ae({
  props: _i(),
  setup(s) {
    var h, m;
    const e = U("usedLanguageText"), t = U("editorId");
    let n = (m = (h = te == null ? void 0 : te.editorExtensions) == null ? void 0 : h.cropper) == null ? void 0 : m.instance;
    const i = ne(), l = ne(), r = ne(), o = xe({
      cropperInited: !1,
      imgSelected: !1,
      imgSrc: "",
      // 是否全屏
      isFullscreen: !1
    });
    let c = null;
    G(() => s.visible, () => {
      s.visible && !o.cropperInited && (n = n || window.Cropper, i.value.onchange = () => {
        if (!n) {
          x.emit(t, "errorCatcher", {
            name: "Cropper",
            message: "Cropper is undefined"
          });
          return;
        }
        const v = i.value.files || [];
        if (o.imgSelected = !0, (v == null ? void 0 : v.length) > 0) {
          const g = new FileReader();
          g.onload = ($) => {
            o.imgSrc = $.target.result, ft(() => {
              c = new n(l.value, {
                viewMode: 2,
                preview: `.${d}-clip-preview-target`
                // aspectRatio: 16 / 9,
              });
            });
          }, g.readAsDataURL(v[0]);
        }
      });
    }), G(() => [o.imgSelected], () => {
      r.value.style = "";
    }), G(() => o.isFullscreen, () => {
      ft(() => {
        c == null || c.destroy(), r.value.style = "", l.value && (c = new n(l.value, {
          viewMode: 2,
          preview: `.${d}-clip-preview-target`
          // aspectRatio: 16 / 9,
        }));
      });
    });
    const f = () => {
      c.clear(), c.destroy(), c = null, i.value.value = "", o.imgSelected = !1;
    };
    return () => {
      var v;
      return u(an, {
        class: `${d}-modal-clip`,
        title: (v = e.value.clipModalTips) == null ? void 0 : v.title,
        visible: s.visible,
        onClose: s.onCancel,
        showAdjust: !0,
        isFullscreen: o.isFullscreen,
        onAdjust: (g) => {
          o.isFullscreen = g;
        },
        width: "668px",
        height: "421px"
      }, {
        default: () => {
          var g, $;
          return [u("div", {
            class: `${d}-form-item ${d}-clip`
          }, [u("div", {
            class: `${d}-clip-main`
          }, [o.imgSelected ? u("div", {
            class: `${d}-clip-cropper`
          }, [u("img", {
            src: o.imgSrc,
            ref: l,
            style: {
              display: "none"
            },
            alt: ""
          }, null), u("div", {
            class: `${d}-clip-delete`,
            onClick: f
          }, [u("svg", {
            class: `${d}-icon`,
            "aria-hidden": "true"
          }, [u("use", {
            "xlink:href": "#md-editor-icon-delete"
          }, null)])])]) : u("div", {
            class: `${d}-clip-upload`,
            onClick: () => {
              i.value.click();
            }
          }, [u("svg", {
            class: `${d}-icon`,
            "aria-hidden": "true"
          }, [u("use", {
            "xlink:href": "#md-editor-icon-upload"
          }, null)])])]), u("div", {
            class: `${d}-clip-preview`
          }, [u("div", {
            class: `${d}-clip-preview-target`,
            ref: r
          }, null)])]), u("div", {
            class: `${d}-form-item`
          }, [u("button", {
            class: `${d}-btn`,
            type: "button",
            onClick: () => {
              if (c) {
                const b = c.getCroppedCanvas();
                x.emit(t, "uploadImage", [di(b.toDataURL("image/png"))], s.onOk), f();
              }
            }
          }, [((g = e.value.clipModalTips) == null ? void 0 : g.buttonUpload) || (($ = e.value.linkModalTips) == null ? void 0 : $.buttonOK)])]), u("input", {
            ref: i,
            accept: "image/*",
            type: "file",
            multiple: !1,
            style: {
              display: "none"
            }
          }, null)];
        }
      });
    };
  }
}), Ii = () => ({
  type: {
    type: String,
    default: "link"
  },
  linkVisible: {
    type: Boolean,
    default: !1
  },
  clipVisible: {
    type: Boolean,
    default: !1
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
}), Li = /* @__PURE__ */ ae({
  props: Ii(),
  setup(s) {
    return () => u(Kt, null, [u(zi, {
      type: s.type,
      visible: s.linkVisible,
      onOk: s.onOk,
      onCancel: s.onCancel
    }, null), u(Ai, {
      visible: s.clipVisible,
      onOk: s.onOk,
      onCancel: s.onCancel
    }, null)]);
  }
}), Fi = (s) => {
  var c, f, h, m;
  const e = U("editorId");
  let t = (f = (c = te.editorExtensions) == null ? void 0 : c.screenfull) == null ? void 0 : f.instance;
  const n = (m = (h = te.editorExtensions) == null ? void 0 : h.screenfull) == null ? void 0 : m.js, i = ne(!1), l = (v) => {
    if (!t) {
      x.emit(e, "errorCatcher", {
        name: "fullscreen",
        message: "fullscreen is undefined"
      });
      return;
    }
    t.isEnabled ? (i.value = !0, (v === void 0 ? !t.isFullscreen : v) ? t.request() : t.exit()) : console.error("browser does not support screenfull!");
  }, r = () => {
    t && t.isEnabled && t.on("change", () => {
      (i.value || s.setting.fullscreen) && (i.value = !1, s.updateSetting("fullscreen"));
    });
  }, o = () => {
    t = window.screenfull, r();
  };
  return ie(() => {
    if (r(), !t) {
      const v = document.createElement("script");
      v.src = n || oi, v.onload = o, v.id = `${d}-screenfull`, we(v, "screenfull");
    }
  }), ie(() => {
    x.on(e, {
      name: jn,
      callback: l
    });
  }), { fullscreenHandler: l };
}, Ri = () => ({
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  onSelected: {
    type: Function,
    default: () => {
    }
  }
}), Oi = /* @__PURE__ */ ae({
  name: "TableShape",
  props: Ri(),
  setup(s) {
    const e = xe({
      x: -1,
      y: -1
    });
    return () => u("div", {
      class: `${d}-table-shape`,
      onMouseleave: () => {
        e.x = -1, e.y = -1;
      }
    }, [new Array(s.tableShape[1]).fill("").map((t, n) => u("div", {
      class: `${d}-table-shape-row`,
      key: `table-shape-row-${n}`
    }, [new Array(s.tableShape[0]).fill("").map((i, l) => u("div", {
      class: `${d}-table-shape-col`,
      key: `table-shape-col-${l}`,
      onMouseenter: () => {
        e.x = n, e.y = l;
      },
      onClick: () => {
        s.onSelected(e);
      }
    }, [u("div", {
      class: [`${d}-table-shape-col-default`, n <= e.x && l <= e.y && `${d}-table-shape-col-include`]
    }, null)]))]))]);
  }
}), Di = () => ({
  noPrettier: {
    type: Boolean
  },
  // 工具栏选择显示
  toolbars: {
    type: Array,
    default: () => []
  },
  // 工具栏选择不显示
  toolbarsExclude: {
    type: Array,
    default: () => []
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  screenfull: {
    type: Object,
    default: null
  },
  screenfullJs: {
    type: String,
    default: ""
  },
  updateSetting: {
    type: Function,
    default: () => {
    }
  },
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  defToolbars: {
    type: Object
  },
  noUploadImg: {
    type: Boolean
  }
}), Hi = /* @__PURE__ */ ae({
  name: "MDEditorToolbar",
  props: Di(),
  setup(s) {
    const e = U("editorId"), t = U("usedLanguageText"), {
      fullscreenHandler: n
    } = Fi(s), i = `${e}-toolbar-wrapper`, l = xe({
      title: !1,
      catalog: !1,
      // 图片上传下拉
      image: !1,
      // 表格预选
      table: !1,
      // mermaid
      mermaid: !1,
      katex: !1
    }), r = (g, $) => {
      x.emit(e, "replace", g, $);
    }, o = xe({
      type: "link",
      linkVisible: !1,
      clipVisible: !1
    }), c = ne();
    ie(() => {
      x.on(e, {
        name: "openModals",
        callback(g) {
          o.type = g, o.linkVisible = !0;
        }
      });
    });
    const f = ze(() => {
      const g = s.toolbars.filter((p) => !s.toolbarsExclude.includes(p)), $ = g.indexOf("="), b = $ === -1 ? g : g.slice(0, $ + 1), k = $ === -1 ? [] : g.slice($, Number.MAX_SAFE_INTEGER);
      return [b, k];
    }), h = ne(), m = () => {
      x.emit(e, "uploadImage", Array.from(h.value.files || [])), h.value.value = "";
    };
    ie(() => {
      h.value.addEventListener("change", m);
    });
    const v = (g) => {
      var $, b, k, p, w, S, C, A, M, T, y, X, V, q, _, O, B, W, H, se, F, D, N, ce, de, ve, Ie, He, Xe, qe, Qe, Tt, Et, nt, it, zt, _t, st, At, It, gt, hn, fn;
      if (Dn.includes(g))
        switch (g) {
          case "-":
            return u(Si, null, null);
          case "bold":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: ($ = t.value.toolbarTips) == null ? void 0 : $.bold,
              onClick: () => {
                r("bold");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-bold"
            }, null)])]);
          case "underline":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (b = t.value.toolbarTips) == null ? void 0 : b.underline,
              onClick: () => {
                r("underline");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-underline"
            }, null)])]);
          case "italic":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (k = t.value.toolbarTips) == null ? void 0 : k.italic,
              onClick: () => {
                r("italic");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-italic"
            }, null)])]);
          case "strikeThrough":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (p = t.value.toolbarTips) == null ? void 0 : p.strikeThrough,
              onClick: () => {
                r("strikeThrough");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-strike-through"
            }, null)])]);
          case "title":
            return u(ot, {
              relative: `#${i}`,
              visible: l.title,
              onChange: (K) => {
                l.title = K;
              },
              overlay: u("ul", {
                class: `${d}-menu`,
                onClick: () => {
                  l.title = !1;
                }
              }, [u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("h1");
                }
              }, [(w = t.value.titleItem) == null ? void 0 : w.h1]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("h2");
                }
              }, [(S = t.value.titleItem) == null ? void 0 : S.h2]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("h3");
                }
              }, [(C = t.value.titleItem) == null ? void 0 : C.h3]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("h4");
                }
              }, [(A = t.value.titleItem) == null ? void 0 : A.h4]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("h5");
                }
              }, [(M = t.value.titleItem) == null ? void 0 : M.h5]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("h6");
                }
              }, [(T = t.value.titleItem) == null ? void 0 : T.h6])])
            }, {
              default: () => {
                var K;
                return [u("div", {
                  class: `${d}-toolbar-item`,
                  title: (K = t.value.toolbarTips) == null ? void 0 : K.title
                }, [u("svg", {
                  class: `${d}-icon`,
                  "aria-hidden": "true"
                }, [u("use", {
                  "xlink:href": "#md-editor-icon-title"
                }, null)])])];
              }
            });
          case "sub":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (y = t.value.toolbarTips) == null ? void 0 : y.sub,
              onClick: () => {
                r("sub");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-sub"
            }, null)])]);
          case "sup":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (X = t.value.toolbarTips) == null ? void 0 : X.sup,
              onClick: () => {
                r("sup");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-sup"
            }, null)])]);
          case "quote":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (V = t.value.toolbarTips) == null ? void 0 : V.quote,
              onClick: () => {
                r("quote");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-quote"
            }, null)])]);
          case "unorderedList":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (q = t.value.toolbarTips) == null ? void 0 : q.unorderedList,
              onClick: () => {
                r("unorderedList");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-unordered-list"
            }, null)])]);
          case "orderedList":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (_ = t.value.toolbarTips) == null ? void 0 : _.orderedList,
              onClick: () => {
                r("orderedList");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-ordered-list"
            }, null)])]);
          case "task":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (O = t.value.toolbarTips) == null ? void 0 : O.task,
              onClick: () => {
                r("task");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-task"
            }, null)])]);
          case "codeRow":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (B = t.value.toolbarTips) == null ? void 0 : B.codeRow,
              onClick: () => {
                r("codeRow");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-code-row"
            }, null)])]);
          case "code":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (W = t.value.toolbarTips) == null ? void 0 : W.code,
              onClick: () => {
                r("code");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-code"
            }, null)])]);
          case "link":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (H = t.value.toolbarTips) == null ? void 0 : H.link,
              onClick: () => {
                o.type = "link", o.linkVisible = !0;
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-link"
            }, null)])]);
          case "image":
            return s.noUploadImg ? u("div", {
              class: `${d}-toolbar-item`,
              title: (se = t.value.toolbarTips) == null ? void 0 : se.image,
              onClick: () => {
                o.type = "image", o.linkVisible = !0;
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-image"
            }, null)])]) : u(ot, {
              relative: `#${i}`,
              visible: l.image,
              onChange: (K) => {
                l.image = K;
              },
              overlay: u("ul", {
                class: `${d}-menu`,
                onClick: () => {
                  l.title = !1;
                }
              }, [u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  o.type = "image", o.linkVisible = !0;
                }
              }, [(F = t.value.imgTitleItem) == null ? void 0 : F.link]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  h.value.click();
                }
              }, [(D = t.value.imgTitleItem) == null ? void 0 : D.upload]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  o.clipVisible = !0;
                }
              }, [(N = t.value.imgTitleItem) == null ? void 0 : N.clip2upload])])
            }, {
              default: () => {
                var K;
                return [u("div", {
                  class: `${d}-toolbar-item`,
                  title: (K = t.value.toolbarTips) == null ? void 0 : K.image
                }, [u("svg", {
                  class: `${d}-icon`,
                  "aria-hidden": "true"
                }, [u("use", {
                  "xlink:href": "#md-editor-icon-image"
                }, null)])])];
              }
            });
          case "table":
            return u(ot, {
              relative: `#${i}`,
              visible: l.table,
              onChange: (K) => {
                l.table = K;
              },
              key: "bar-table",
              overlay: u(Oi, {
                tableShape: s.tableShape,
                onSelected: (K) => {
                  r("table", {
                    selectedShape: K
                  });
                }
              }, null)
            }, {
              default: () => {
                var K;
                return [u("div", {
                  class: `${d}-toolbar-item`,
                  title: (K = t.value.toolbarTips) == null ? void 0 : K.table
                }, [u("svg", {
                  class: `${d}-icon`,
                  "aria-hidden": "true"
                }, [u("use", {
                  "xlink:href": "#md-editor-icon-table"
                }, null)])])];
              }
            });
          case "revoke":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (ce = t.value.toolbarTips) == null ? void 0 : ce.revoke,
              onClick: () => {
                x.emit(e, "ctrlZ");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-revoke"
            }, null)])]);
          case "next":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (de = t.value.toolbarTips) == null ? void 0 : de.next,
              onClick: () => {
                x.emit(e, "ctrlShiftZ");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-next"
            }, null)])]);
          case "save":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (ve = t.value.toolbarTips) == null ? void 0 : ve.save,
              onClick: () => {
                x.emit(e, Ut);
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-baocun"
            }, null)])]);
          case "prettier":
            return s.noPrettier ? "" : u("div", {
              class: `${d}-toolbar-item`,
              title: (Ie = t.value.toolbarTips) == null ? void 0 : Ie.prettier,
              onClick: () => {
                r("prettier");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-prettier"
            }, null)])]);
          case "pageFullscreen":
            return !s.setting.fullscreen && u("div", {
              class: `${d}-toolbar-item`,
              title: (He = t.value.toolbarTips) == null ? void 0 : He.pageFullscreen,
              onClick: () => {
                s.updateSetting("pageFullscreen");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": `#md-editor-icon-${s.setting.pageFullscreen ? "suoxiao" : "fangda"}`
            }, null)])]);
          case "fullscreen":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (Xe = t.value.toolbarTips) == null ? void 0 : Xe.fullscreen,
              onClick: () => {
                n();
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": `#md-editor-icon-${s.setting.fullscreen ? "fullscreen-exit" : "fullscreen"}`
            }, null)])]);
          case "preview":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (qe = t.value.toolbarTips) == null ? void 0 : qe.preview,
              onClick: () => {
                s.updateSetting("preview");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-preview"
            }, null)])]);
          case "htmlPreview":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (Qe = t.value.toolbarTips) == null ? void 0 : Qe.htmlPreview,
              onClick: () => {
                s.updateSetting("htmlPreview");
              }
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-coding"
            }, null)])]);
          case "catalog":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (Tt = t.value.toolbarTips) == null ? void 0 : Tt.catalog,
              onClick: () => {
                x.emit(e, rn);
              },
              key: "bar-catalog"
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-catalog"
            }, null)])]);
          case "github":
            return u("div", {
              class: `${d}-toolbar-item`,
              title: (Et = t.value.toolbarTips) == null ? void 0 : Et.github,
              onClick: () => ui("https://github.com/imzbf/md-editor-v3")
            }, [u("svg", {
              class: `${d}-icon`,
              "aria-hidden": "true"
            }, [u("use", {
              "xlink:href": "#md-editor-icon-github"
            }, null)])]);
          case "mermaid":
            return u(ot, {
              relative: `#${i}`,
              visible: l.mermaid,
              onChange: (K) => {
                l.mermaid = K;
              },
              overlay: u("ul", {
                class: `${d}-menu`,
                onClick: () => {
                  l.mermaid = !1;
                }
              }, [u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("flow");
                }
              }, [(nt = t.value.mermaid) == null ? void 0 : nt.flow]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("sequence");
                }
              }, [(it = t.value.mermaid) == null ? void 0 : it.sequence]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("gantt");
                }
              }, [(zt = t.value.mermaid) == null ? void 0 : zt.gantt]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("class");
                }
              }, [(_t = t.value.mermaid) == null ? void 0 : _t.class]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("state");
                }
              }, [(st = t.value.mermaid) == null ? void 0 : st.state]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("pie");
                }
              }, [(At = t.value.mermaid) == null ? void 0 : At.pie]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("relationship");
                }
              }, [(It = t.value.mermaid) == null ? void 0 : It.relationship]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("journey");
                }
              }, [(gt = t.value.mermaid) == null ? void 0 : gt.journey])]),
              key: "bar-mermaid"
            }, {
              default: () => {
                var K;
                return [u("div", {
                  class: `${d}-toolbar-item`,
                  title: (K = t.value.toolbarTips) == null ? void 0 : K.mermaid
                }, [u("svg", {
                  class: `${d}-icon`,
                  "aria-hidden": "true"
                }, [u("use", {
                  "xlink:href": "#md-editor-icon-mermaid"
                }, null)])])];
              }
            });
          case "katex":
            return u(ot, {
              relative: `#${i}`,
              visible: l.katex,
              onChange: (K) => {
                l.katex = K;
              },
              overlay: u("ul", {
                class: `${d}-menu`,
                onClick: () => {
                  l.katex = !1;
                }
              }, [u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("katexInline");
                }
              }, [(hn = t.value.katex) == null ? void 0 : hn.inline]), u("li", {
                class: `${d}-menu-item`,
                onClick: () => {
                  r("katexBlock");
                }
              }, [(fn = t.value.katex) == null ? void 0 : fn.block])]),
              key: "bar-katex"
            }, {
              default: () => {
                var K;
                return [u("div", {
                  class: `${d}-toolbar-item`,
                  title: (K = t.value.toolbarTips) == null ? void 0 : K.katex
                }, [u("svg", {
                  class: `${d}-icon`,
                  "aria-hidden": "true"
                }, [u("use", {
                  "xlink:href": "#md-editor-icon-formula"
                }, null)])])];
              }
            });
        }
      else
        return s.defToolbars instanceof Array ? s.defToolbars[g] || "" : s.defToolbars && s.defToolbars.children instanceof Array && s.defToolbars.children[g] || "";
    };
    return () => {
      const g = f.value[0].map((b) => v(b)), $ = f.value[1].map((b) => v(b));
      return u(Kt, null, [s.toolbars.length > 0 && u("div", {
        class: `${d}-toolbar-wrapper`,
        id: i
      }, [u("div", {
        class: `${d}-toolbar`
      }, [u("div", {
        class: `${d}-toolbar-left`,
        ref: c
      }, [g]), u("div", {
        class: `${d}-toolbar-right`
      }, [$])])]), u("input", {
        ref: h,
        accept: "image/*",
        type: "file",
        multiple: !0,
        style: {
          display: "none"
        }
      }, null), u(Li, {
        linkVisible: o.linkVisible,
        clipVisible: o.clipVisible,
        type: o.type,
        onCancel: () => {
          o.linkVisible = !1, o.clipVisible = !1;
        },
        onOk: (b) => {
          b && r(o.type, {
            desc: b.desc,
            url: b.url
          }), o.linkVisible = !1, o.clipVisible = !1;
        }
      }, null)]);
    };
  }
});
function Mn() {
  return {
    async: !1,
    baseUrl: null,
    breaks: !1,
    extensions: null,
    gfm: !0,
    headerIds: !0,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: !0,
    pedantic: !1,
    renderer: null,
    sanitize: !1,
    sanitizer: null,
    silent: !1,
    smartypants: !1,
    tokenizer: null,
    walkTokens: null,
    xhtml: !1
  };
}
let mt = Mn();
function ji(s) {
  mt = s;
}
const Bn = /[&<>"']/, Pi = new RegExp(Bn.source, "g"), Nn = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, Mi = new RegExp(Nn.source, "g"), Bi = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, Tn = (s) => Bi[s];
function fe(s, e) {
  if (e) {
    if (Bn.test(s))
      return s.replace(Pi, Tn);
  } else if (Nn.test(s))
    return s.replace(Mi, Tn);
  return s;
}
const Ni = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function Un(s) {
  return s.replace(Ni, (e, t) => (t = t.toLowerCase(), t === "colon" ? ":" : t.charAt(0) === "#" ? t.charAt(1) === "x" ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : ""));
}
const Ui = /(^|[^\[])\^/g;
function Z(s, e) {
  s = typeof s == "string" ? s : s.source, e = e || "";
  const t = {
    replace: (n, i) => (i = i.source || i, i = i.replace(Ui, "$1"), s = s.replace(n, i), t),
    getRegex: () => new RegExp(s, e)
  };
  return t;
}
const qi = /[^\w:]/g, Vi = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function En(s, e, t) {
  if (s) {
    let n;
    try {
      n = decodeURIComponent(Un(t)).replace(qi, "").toLowerCase();
    } catch {
      return null;
    }
    if (n.indexOf("javascript:") === 0 || n.indexOf("vbscript:") === 0 || n.indexOf("data:") === 0)
      return null;
  }
  e && !Vi.test(t) && (t = Zi(e, t));
  try {
    t = encodeURI(t).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return t;
}
const Ft = {}, Wi = /^[^:]+:\/*[^/]*$/, Ki = /^([^:]+:)[\s\S]*$/, Gi = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function Zi(s, e) {
  Ft[" " + s] || (Wi.test(s) ? Ft[" " + s] = s + "/" : Ft[" " + s] = Ot(s, "/", !0)), s = Ft[" " + s];
  const t = s.indexOf(":") === -1;
  return e.substring(0, 2) === "//" ? t ? e : s.replace(Ki, "$1") + e : e.charAt(0) === "/" ? t ? e : s.replace(Gi, "$1") + e : s + e;
}
const qt = { exec: function() {
} };
function Ae(s) {
  let e = 1, t, n;
  for (; e < arguments.length; e++) {
    t = arguments[e];
    for (n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (s[n] = t[n]);
  }
  return s;
}
function zn(s, e) {
  const t = s.replace(/\|/g, (l, r, o) => {
    let c = !1, f = r;
    for (; --f >= 0 && o[f] === "\\"; )
      c = !c;
    return c ? "|" : " |";
  }), n = t.split(/ \|/);
  let i = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), n.length > e)
    n.splice(e);
  else
    for (; n.length < e; )
      n.push("");
  for (; i < n.length; i++)
    n[i] = n[i].trim().replace(/\\\|/g, "|");
  return n;
}
function Ot(s, e, t) {
  const n = s.length;
  if (n === 0)
    return "";
  let i = 0;
  for (; i < n; ) {
    const l = s.charAt(n - i - 1);
    if (l === e && !t)
      i++;
    else if (l !== e && t)
      i++;
    else
      break;
  }
  return s.slice(0, n - i);
}
function Xi(s, e) {
  if (s.indexOf(e[1]) === -1)
    return -1;
  const t = s.length;
  let n = 0, i = 0;
  for (; i < t; i++)
    if (s[i] === "\\")
      i++;
    else if (s[i] === e[0])
      n++;
    else if (s[i] === e[1] && (n--, n < 0))
      return i;
  return -1;
}
function qn(s) {
  s && s.sanitize && !s.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
}
function _n(s, e) {
  if (e < 1)
    return "";
  let t = "";
  for (; e > 1; )
    e & 1 && (t += s), e >>= 1, s += s;
  return t + s;
}
function An(s, e, t, n) {
  const i = e.href, l = e.title ? fe(e.title) : null, r = s[1].replace(/\\([\[\]])/g, "$1");
  if (s[0].charAt(0) !== "!") {
    n.state.inLink = !0;
    const o = {
      type: "link",
      raw: t,
      href: i,
      title: l,
      text: r,
      tokens: n.inlineTokens(r)
    };
    return n.state.inLink = !1, o;
  }
  return {
    type: "image",
    raw: t,
    href: i,
    title: l,
    text: fe(r)
  };
}
function Qi(s, e) {
  const t = s.match(/^(\s+)(?:```)/);
  if (t === null)
    return e;
  const n = t[1];
  return e.split(`
`).map((i) => {
    const l = i.match(/^\s+/);
    if (l === null)
      return i;
    const [r] = l;
    return r.length >= n.length ? i.slice(n.length) : i;
  }).join(`
`);
}
class cn {
  constructor(e) {
    this.options = e || mt;
  }
  space(e) {
    const t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0)
      return {
        type: "space",
        raw: t[0]
      };
  }
  code(e) {
    const t = this.rules.block.code.exec(e);
    if (t) {
      const n = t[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: t[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? n : Ot(n, `
`)
      };
    }
  }
  fences(e) {
    const t = this.rules.block.fences.exec(e);
    if (t) {
      const n = t[0], i = Qi(n, t[3] || "");
      return {
        type: "code",
        raw: n,
        lang: t[2] ? t[2].trim().replace(this.rules.inline._escapes, "$1") : t[2],
        text: i
      };
    }
  }
  heading(e) {
    const t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (/#$/.test(n)) {
        const i = Ot(n, "#");
        (this.options.pedantic || !i || / $/.test(i)) && (n = i.trim());
      }
      return {
        type: "heading",
        raw: t[0],
        depth: t[1].length,
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  hr(e) {
    const t = this.rules.block.hr.exec(e);
    if (t)
      return {
        type: "hr",
        raw: t[0]
      };
  }
  blockquote(e) {
    const t = this.rules.block.blockquote.exec(e);
    if (t) {
      const n = t[0].replace(/^ *>[ \t]?/gm, ""), i = this.lexer.state.top;
      this.lexer.state.top = !0;
      const l = this.lexer.blockTokens(n);
      return this.lexer.state.top = i, {
        type: "blockquote",
        raw: t[0],
        tokens: l,
        text: n
      };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n, i, l, r, o, c, f, h, m, v, g, $, b = t[1].trim();
      const k = b.length > 1, p = {
        type: "list",
        raw: "",
        ordered: k,
        start: k ? +b.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      b = k ? `\\d{1,9}\\${b.slice(-1)}` : `\\${b}`, this.options.pedantic && (b = k ? b : "[*+-]");
      const w = new RegExp(`^( {0,3}${b})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      for (; e && ($ = !1, !(!(t = w.exec(e)) || this.rules.block.hr.test(e))); ) {
        if (n = t[0], e = e.substring(n.length), h = t[2].split(`
`, 1)[0].replace(/^\t+/, (C) => " ".repeat(3 * C.length)), m = e.split(`
`, 1)[0], this.options.pedantic ? (r = 2, g = h.trimLeft()) : (r = t[2].search(/[^ ]/), r = r > 4 ? 1 : r, g = h.slice(r), r += t[1].length), c = !1, !h && /^ *$/.test(m) && (n += m + `
`, e = e.substring(m.length + 1), $ = !0), !$) {
          const C = new RegExp(`^ {0,${Math.min(3, r - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), A = new RegExp(`^ {0,${Math.min(3, r - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), M = new RegExp(`^ {0,${Math.min(3, r - 1)}}(?:\`\`\`|~~~)`), T = new RegExp(`^ {0,${Math.min(3, r - 1)}}#`);
          for (; e && (v = e.split(`
`, 1)[0], m = v, this.options.pedantic && (m = m.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !(M.test(m) || T.test(m) || C.test(m) || A.test(e))); ) {
            if (m.search(/[^ ]/) >= r || !m.trim())
              g += `
` + m.slice(r);
            else {
              if (c || h.search(/[^ ]/) >= 4 || M.test(h) || T.test(h) || A.test(h))
                break;
              g += `
` + m;
            }
            !c && !m.trim() && (c = !0), n += v + `
`, e = e.substring(v.length + 1), h = m.slice(r);
          }
        }
        p.loose || (f ? p.loose = !0 : /\n *\n *$/.test(n) && (f = !0)), this.options.gfm && (i = /^\[[ xX]\] /.exec(g), i && (l = i[0] !== "[ ] ", g = g.replace(/^\[[ xX]\] +/, ""))), p.items.push({
          type: "list_item",
          raw: n,
          task: !!i,
          checked: l,
          loose: !1,
          text: g
        }), p.raw += n;
      }
      p.items[p.items.length - 1].raw = n.trimRight(), p.items[p.items.length - 1].text = g.trimRight(), p.raw = p.raw.trimRight();
      const S = p.items.length;
      for (o = 0; o < S; o++)
        if (this.lexer.state.top = !1, p.items[o].tokens = this.lexer.blockTokens(p.items[o].text, []), !p.loose) {
          const C = p.items[o].tokens.filter((M) => M.type === "space"), A = C.length > 0 && C.some((M) => /\n.*\n/.test(M.raw));
          p.loose = A;
        }
      if (p.loose)
        for (o = 0; o < S; o++)
          p.items[o].loose = !0;
      return p;
    }
  }
  html(e) {
    const t = this.rules.block.html.exec(e);
    if (t) {
      const n = {
        type: "html",
        raw: t[0],
        pre: !this.options.sanitizer && (t[1] === "pre" || t[1] === "script" || t[1] === "style"),
        text: t[0]
      };
      if (this.options.sanitize) {
        const i = this.options.sanitizer ? this.options.sanitizer(t[0]) : fe(t[0]);
        n.type = "paragraph", n.text = i, n.tokens = this.lexer.inline(i);
      }
      return n;
    }
  }
  def(e) {
    const t = this.rules.block.def.exec(e);
    if (t) {
      const n = t[1].toLowerCase().replace(/\s+/g, " "), i = t[2] ? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "", l = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline._escapes, "$1") : t[3];
      return {
        type: "def",
        tag: n,
        raw: t[0],
        href: i,
        title: l
      };
    }
  }
  table(e) {
    const t = this.rules.block.table.exec(e);
    if (t) {
      const n = {
        type: "table",
        header: zn(t[1]).map((i) => ({ text: i })),
        align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: t[3] && t[3].trim() ? t[3].replace(/\n[ \t]*$/, "").split(`
`) : []
      };
      if (n.header.length === n.align.length) {
        n.raw = t[0];
        let i = n.align.length, l, r, o, c;
        for (l = 0; l < i; l++)
          /^ *-+: *$/.test(n.align[l]) ? n.align[l] = "right" : /^ *:-+: *$/.test(n.align[l]) ? n.align[l] = "center" : /^ *:-+ *$/.test(n.align[l]) ? n.align[l] = "left" : n.align[l] = null;
        for (i = n.rows.length, l = 0; l < i; l++)
          n.rows[l] = zn(n.rows[l], n.header.length).map((f) => ({ text: f }));
        for (i = n.header.length, r = 0; r < i; r++)
          n.header[r].tokens = this.lexer.inline(n.header[r].text);
        for (i = n.rows.length, r = 0; r < i; r++)
          for (c = n.rows[r], o = 0; o < c.length; o++)
            c[o].tokens = this.lexer.inline(c[o].text);
        return n;
      }
    }
  }
  lheading(e) {
    const t = this.rules.block.lheading.exec(e);
    if (t)
      return {
        type: "heading",
        raw: t[0],
        depth: t[2].charAt(0) === "=" ? 1 : 2,
        text: t[1],
        tokens: this.lexer.inline(t[1])
      };
  }
  paragraph(e) {
    const t = this.rules.block.paragraph.exec(e);
    if (t) {
      const n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return {
        type: "paragraph",
        raw: t[0],
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  text(e) {
    const t = this.rules.block.text.exec(e);
    if (t)
      return {
        type: "text",
        raw: t[0],
        text: t[0],
        tokens: this.lexer.inline(t[0])
      };
  }
  escape(e) {
    const t = this.rules.inline.escape.exec(e);
    if (t)
      return {
        type: "escape",
        raw: t[0],
        text: fe(t[1])
      };
  }
  tag(e) {
    const t = this.rules.inline.tag.exec(e);
    if (t)
      return !this.lexer.state.inLink && /^<a /i.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) && (this.lexer.state.inRawBlock = !1), {
        type: this.options.sanitize ? "text" : "html",
        raw: t[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(t[0]) : fe(t[0]) : t[0]
      };
  }
  link(e) {
    const t = this.rules.inline.link.exec(e);
    if (t) {
      const n = t[2].trim();
      if (!this.options.pedantic && /^</.test(n)) {
        if (!/>$/.test(n))
          return;
        const r = Ot(n.slice(0, -1), "\\");
        if ((n.length - r.length) % 2 === 0)
          return;
      } else {
        const r = Xi(t[2], "()");
        if (r > -1) {
          const c = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + r;
          t[2] = t[2].substring(0, r), t[0] = t[0].substring(0, c).trim(), t[3] = "";
        }
      }
      let i = t[2], l = "";
      if (this.options.pedantic) {
        const r = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(i);
        r && (i = r[1], l = r[3]);
      } else
        l = t[3] ? t[3].slice(1, -1) : "";
      return i = i.trim(), /^</.test(i) && (this.options.pedantic && !/>$/.test(n) ? i = i.slice(1) : i = i.slice(1, -1)), An(t, {
        href: i && i.replace(this.rules.inline._escapes, "$1"),
        title: l && l.replace(this.rules.inline._escapes, "$1")
      }, t[0], this.lexer);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let i = (n[2] || n[1]).replace(/\s+/g, " ");
      if (i = t[i.toLowerCase()], !i) {
        const l = n[0].charAt(0);
        return {
          type: "text",
          raw: l,
          text: l
        };
      }
      return An(n, i, n[0], this.lexer);
    }
  }
  emStrong(e, t, n = "") {
    let i = this.rules.inline.emStrong.lDelim.exec(e);
    if (!i || i[3] && n.match(/[\p{L}\p{N}]/u))
      return;
    const l = i[1] || i[2] || "";
    if (!l || l && (n === "" || this.rules.inline.punctuation.exec(n))) {
      const r = i[0].length - 1;
      let o, c, f = r, h = 0;
      const m = i[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      for (m.lastIndex = 0, t = t.slice(-1 * e.length + r); (i = m.exec(t)) != null; ) {
        if (o = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !o)
          continue;
        if (c = o.length, i[3] || i[4]) {
          f += c;
          continue;
        } else if ((i[5] || i[6]) && r % 3 && !((r + c) % 3)) {
          h += c;
          continue;
        }
        if (f -= c, f > 0)
          continue;
        c = Math.min(c, c + f + h);
        const v = e.slice(0, r + i.index + (i[0].length - o.length) + c);
        if (Math.min(r, c) % 2) {
          const $ = v.slice(1, -1);
          return {
            type: "em",
            raw: v,
            text: $,
            tokens: this.lexer.inlineTokens($)
          };
        }
        const g = v.slice(2, -2);
        return {
          type: "strong",
          raw: v,
          text: g,
          tokens: this.lexer.inlineTokens(g)
        };
      }
    }
  }
  codespan(e) {
    const t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(/\n/g, " ");
      const i = /[^ ]/.test(n), l = /^ /.test(n) && / $/.test(n);
      return i && l && (n = n.substring(1, n.length - 1)), n = fe(n, !0), {
        type: "codespan",
        raw: t[0],
        text: n
      };
    }
  }
  br(e) {
    const t = this.rules.inline.br.exec(e);
    if (t)
      return {
        type: "br",
        raw: t[0]
      };
  }
  del(e) {
    const t = this.rules.inline.del.exec(e);
    if (t)
      return {
        type: "del",
        raw: t[0],
        text: t[2],
        tokens: this.lexer.inlineTokens(t[2])
      };
  }
  autolink(e, t) {
    const n = this.rules.inline.autolink.exec(e);
    if (n) {
      let i, l;
      return n[2] === "@" ? (i = fe(this.options.mangle ? t(n[1]) : n[1]), l = "mailto:" + i) : (i = fe(n[1]), l = i), {
        type: "link",
        raw: n[0],
        text: i,
        href: l,
        tokens: [
          {
            type: "text",
            raw: i,
            text: i
          }
        ]
      };
    }
  }
  url(e, t) {
    let n;
    if (n = this.rules.inline.url.exec(e)) {
      let i, l;
      if (n[2] === "@")
        i = fe(this.options.mangle ? t(n[0]) : n[0]), l = "mailto:" + i;
      else {
        let r;
        do
          r = n[0], n[0] = this.rules.inline._backpedal.exec(n[0])[0];
        while (r !== n[0]);
        i = fe(n[0]), n[1] === "www." ? l = "http://" + n[0] : l = n[0];
      }
      return {
        type: "link",
        raw: n[0],
        text: i,
        href: l,
        tokens: [
          {
            type: "text",
            raw: i,
            text: i
          }
        ]
      };
    }
  }
  inlineText(e, t) {
    const n = this.rules.inline.text.exec(e);
    if (n) {
      let i;
      return this.lexer.state.inRawBlock ? i = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(n[0]) : fe(n[0]) : n[0] : i = fe(this.options.smartypants ? t(n[0]) : n[0]), {
        type: "text",
        raw: n[0],
        text: i
      };
    }
  }
}
const L = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: qt,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
L._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
L._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
L.def = Z(L.def).replace("label", L._label).replace("title", L._title).getRegex();
L.bullet = /(?:[*+-]|\d{1,9}[.)])/;
L.listItemStart = Z(/^( *)(bull) */).replace("bull", L.bullet).getRegex();
L.list = Z(L.list).replace(/bull/g, L.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + L.def.source + ")").getRegex();
L._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
L._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
L.html = Z(L.html, "i").replace("comment", L._comment).replace("tag", L._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
L.paragraph = Z(L._paragraph).replace("hr", L.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", L._tag).getRegex();
L.blockquote = Z(L.blockquote).replace("paragraph", L.paragraph).getRegex();
L.normal = Ae({}, L);
L.gfm = Ae({}, L.normal, {
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
});
L.gfm.table = Z(L.gfm.table).replace("hr", L.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", L._tag).getRegex();
L.gfm.paragraph = Z(L._paragraph).replace("hr", L.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", L.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", L._tag).getRegex();
L.pedantic = Ae({}, L.normal, {
  html: Z(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", L._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: qt,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: Z(L.normal._paragraph).replace("hr", L.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", L.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
});
const E = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: qt,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: qt,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
E._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
E.punctuation = Z(E.punctuation).replace(/punctuation/g, E._punctuation).getRegex();
E.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
E.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
E._comment = Z(L._comment).replace("(?:-->|$)", "-->").getRegex();
E.emStrong.lDelim = Z(E.emStrong.lDelim).replace(/punct/g, E._punctuation).getRegex();
E.emStrong.rDelimAst = Z(E.emStrong.rDelimAst, "g").replace(/punct/g, E._punctuation).getRegex();
E.emStrong.rDelimUnd = Z(E.emStrong.rDelimUnd, "g").replace(/punct/g, E._punctuation).getRegex();
E._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
E._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
E._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
E.autolink = Z(E.autolink).replace("scheme", E._scheme).replace("email", E._email).getRegex();
E._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
E.tag = Z(E.tag).replace("comment", E._comment).replace("attribute", E._attribute).getRegex();
E._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
E._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
E._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
E.link = Z(E.link).replace("label", E._label).replace("href", E._href).replace("title", E._title).getRegex();
E.reflink = Z(E.reflink).replace("label", E._label).replace("ref", L._label).getRegex();
E.nolink = Z(E.nolink).replace("ref", L._label).getRegex();
E.reflinkSearch = Z(E.reflinkSearch, "g").replace("reflink", E.reflink).replace("nolink", E.nolink).getRegex();
E.normal = Ae({}, E);
E.pedantic = Ae({}, E.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: Z(/^!?\[(label)\]\((.*?)\)/).replace("label", E._label).getRegex(),
  reflink: Z(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", E._label).getRegex()
});
E.gfm = Ae({}, E.normal, {
  escape: Z(E.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
E.gfm.url = Z(E.gfm.url, "i").replace("email", E.gfm._extended_email).getRegex();
E.breaks = Ae({}, E.gfm, {
  br: Z(E.br).replace("{2,}", "*").getRegex(),
  text: Z(E.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
});
function Yi(s) {
  return s.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function In(s) {
  let e = "", t, n;
  const i = s.length;
  for (t = 0; t < i; t++)
    n = s.charCodeAt(t), Math.random() > 0.5 && (n = "x" + n.toString(16)), e += "&#" + n + ";";
  return e;
}
class Ue {
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || mt, this.options.tokenizer = this.options.tokenizer || new cn(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const t = {
      block: L.normal,
      inline: E.normal
    };
    this.options.pedantic ? (t.block = L.pedantic, t.inline = E.pedantic) : this.options.gfm && (t.block = L.gfm, this.options.breaks ? t.inline = E.breaks : t.inline = E.gfm), this.tokenizer.rules = t;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: L,
      inline: E
    };
  }
  /**
   * Static Lex Method
   */
  static lex(e, t) {
    return new Ue(t).lex(e);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(e, t) {
    return new Ue(t).inlineTokens(e);
  }
  /**
   * Preprocessing
   */
  lex(e) {
    e = e.replace(/\r\n|\r/g, `
`), this.blockTokens(e, this.tokens);
    let t;
    for (; t = this.inlineQueue.shift(); )
      this.inlineTokens(t.src, t.tokens);
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(e, t = []) {
    this.options.pedantic ? e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e = e.replace(/^( *)(\t+)/gm, (o, c, f) => c + "    ".repeat(f.length));
    let n, i, l, r;
    for (; e; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((o) => (n = o.call({ lexer: this }, e, t)) ? (e = e.substring(n.raw.length), t.push(n), !0) : !1))) {
        if (n = this.tokenizer.space(e)) {
          e = e.substring(n.raw.length), n.raw.length === 1 && t.length > 0 ? t[t.length - 1].raw += `
` : t.push(n);
          continue;
        }
        if (n = this.tokenizer.code(e)) {
          e = e.substring(n.raw.length), i = t[t.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
` + n.raw, i.text += `
` + n.text, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n);
          continue;
        }
        if (n = this.tokenizer.fences(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.heading(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.hr(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.blockquote(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.list(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.html(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.def(e)) {
          e = e.substring(n.raw.length), i = t[t.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
` + n.raw, i.text += `
` + n.raw, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : this.tokens.links[n.tag] || (this.tokens.links[n.tag] = {
            href: n.href,
            title: n.title
          });
          continue;
        }
        if (n = this.tokenizer.table(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.lheading(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (l = e, this.options.extensions && this.options.extensions.startBlock) {
          let o = 1 / 0;
          const c = e.slice(1);
          let f;
          this.options.extensions.startBlock.forEach(function(h) {
            f = h.call({ lexer: this }, c), typeof f == "number" && f >= 0 && (o = Math.min(o, f));
          }), o < 1 / 0 && o >= 0 && (l = e.substring(0, o + 1));
        }
        if (this.state.top && (n = this.tokenizer.paragraph(l))) {
          i = t[t.length - 1], r && i.type === "paragraph" ? (i.raw += `
` + n.raw, i.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n), r = l.length !== e.length, e = e.substring(n.raw.length);
          continue;
        }
        if (n = this.tokenizer.text(e)) {
          e = e.substring(n.raw.length), i = t[t.length - 1], i && i.type === "text" ? (i.raw += `
` + n.raw, i.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n);
          continue;
        }
        if (e) {
          const o = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(o);
            break;
          } else
            throw new Error(o);
        }
      }
    return this.state.top = !0, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(e, t = []) {
    let n, i, l, r = e, o, c, f;
    if (this.tokens.links) {
      const h = Object.keys(this.tokens.links);
      if (h.length > 0)
        for (; (o = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null; )
          h.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, o.index) + "[" + _n("a", o[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (o = this.tokenizer.rules.inline.blockSkip.exec(r)) != null; )
      r = r.slice(0, o.index) + "[" + _n("a", o[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (o = this.tokenizer.rules.inline.escapedEmSt.exec(r)) != null; )
      r = r.slice(0, o.index + o[0].length - 2) + "++" + r.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex), this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    for (; e; )
      if (c || (f = ""), c = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((h) => (n = h.call({ lexer: this }, e, t)) ? (e = e.substring(n.raw.length), t.push(n), !0) : !1))) {
        if (n = this.tokenizer.escape(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.tag(e)) {
          e = e.substring(n.raw.length), i = t[t.length - 1], i && n.type === "text" && i.type === "text" ? (i.raw += n.raw, i.text += n.text) : t.push(n);
          continue;
        }
        if (n = this.tokenizer.link(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.reflink(e, this.tokens.links)) {
          e = e.substring(n.raw.length), i = t[t.length - 1], i && n.type === "text" && i.type === "text" ? (i.raw += n.raw, i.text += n.text) : t.push(n);
          continue;
        }
        if (n = this.tokenizer.emStrong(e, r, f)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.codespan(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.br(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.del(e)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (n = this.tokenizer.autolink(e, In)) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (!this.state.inLink && (n = this.tokenizer.url(e, In))) {
          e = e.substring(n.raw.length), t.push(n);
          continue;
        }
        if (l = e, this.options.extensions && this.options.extensions.startInline) {
          let h = 1 / 0;
          const m = e.slice(1);
          let v;
          this.options.extensions.startInline.forEach(function(g) {
            v = g.call({ lexer: this }, m), typeof v == "number" && v >= 0 && (h = Math.min(h, v));
          }), h < 1 / 0 && h >= 0 && (l = e.substring(0, h + 1));
        }
        if (n = this.tokenizer.inlineText(l, Yi)) {
          e = e.substring(n.raw.length), n.raw.slice(-1) !== "_" && (f = n.raw.slice(-1)), c = !0, i = t[t.length - 1], i && i.type === "text" ? (i.raw += n.raw, i.text += n.text) : t.push(n);
          continue;
        }
        if (e) {
          const h = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(h);
            break;
          } else
            throw new Error(h);
        }
      }
    return t;
  }
}
class un {
  constructor(e) {
    this.options = e || mt;
  }
  code(e, t, n) {
    const i = (t || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const l = this.options.highlight(e, i);
      l != null && l !== e && (n = !0, e = l);
    }
    return e = e.replace(/\n$/, "") + `
`, i ? '<pre><code class="' + this.options.langPrefix + fe(i) + '">' + (n ? e : fe(e, !0)) + `</code></pre>
` : "<pre><code>" + (n ? e : fe(e, !0)) + `</code></pre>
`;
  }
  /**
   * @param {string} quote
   */
  blockquote(e) {
    return `<blockquote>
${e}</blockquote>
`;
  }
  html(e) {
    return e;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(e, t, n, i) {
    if (this.options.headerIds) {
      const l = this.options.headerPrefix + i.slug(n);
      return `<h${t} id="${l}">${e}</h${t}>
`;
    }
    return `<h${t}>${e}</h${t}>
`;
  }
  hr() {
    return this.options.xhtml ? `<hr/>
` : `<hr>
`;
  }
  list(e, t, n) {
    const i = t ? "ol" : "ul", l = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + l + `>
` + e + "</" + i + `>
`;
  }
  /**
   * @param {string} text
   */
  listitem(e) {
    return `<li>${e}</li>
`;
  }
  checkbox(e) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(e) {
    return `<p>${e}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(e, t) {
    return t && (t = `<tbody>${t}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + t + `</table>
`;
  }
  /**
   * @param {string} content
   */
  tablerow(e) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e, t) {
    const n = t.header ? "th" : "td";
    return (t.align ? `<${n} align="${t.align}">` : `<${n}>`) + e + `</${n}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(e) {
    return `<strong>${e}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(e) {
    return `<em>${e}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(e) {
    return `<code>${e}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(e) {
    return `<del>${e}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(e, t, n) {
    if (e = En(this.options.sanitize, this.options.baseUrl, e), e === null)
      return n;
    let i = '<a href="' + e + '"';
    return t && (i += ' title="' + t + '"'), i += ">" + n + "</a>", i;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(e, t, n) {
    if (e = En(this.options.sanitize, this.options.baseUrl, e), e === null)
      return n;
    let i = `<img src="${e}" alt="${n}"`;
    return t && (i += ` title="${t}"`), i += this.options.xhtml ? "/>" : ">", i;
  }
  text(e) {
    return e;
  }
}
class Vn {
  // no need for block level renderers
  strong(e) {
    return e;
  }
  em(e) {
    return e;
  }
  codespan(e) {
    return e;
  }
  del(e) {
    return e;
  }
  html(e) {
    return e;
  }
  text(e) {
    return e;
  }
  link(e, t, n) {
    return "" + n;
  }
  image(e, t, n) {
    return "" + n;
  }
  br() {
    return "";
  }
}
class Wn {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(e) {
    return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(e, t) {
    let n = e, i = 0;
    if (this.seen.hasOwnProperty(n)) {
      i = this.seen[e];
      do
        i++, n = e + "-" + i;
      while (this.seen.hasOwnProperty(n));
    }
    return t || (this.seen[e] = i, this.seen[n] = 0), n;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(e, t = {}) {
    const n = this.serialize(e);
    return this.getNextSafeSlug(n, t.dryrun);
  }
}
class De {
  constructor(e) {
    this.options = e || mt, this.options.renderer = this.options.renderer || new un(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new Vn(), this.slugger = new Wn();
  }
  /**
   * Static Parse Method
   */
  static parse(e, t) {
    return new De(t).parse(e);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(e, t) {
    return new De(t).parseInline(e);
  }
  /**
   * Parse Loop
   */
  parse(e, t = !0) {
    let n = "", i, l, r, o, c, f, h, m, v, g, $, b, k, p, w, S, C, A, M;
    const T = e.length;
    for (i = 0; i < T; i++) {
      if (g = e[i], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[g.type] && (M = this.options.extensions.renderers[g.type].call({ parser: this }, g), M !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(g.type))) {
        n += M || "";
        continue;
      }
      switch (g.type) {
        case "space":
          continue;
        case "hr": {
          n += this.renderer.hr();
          continue;
        }
        case "heading": {
          n += this.renderer.heading(
            this.parseInline(g.tokens),
            g.depth,
            Un(this.parseInline(g.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          n += this.renderer.code(
            g.text,
            g.lang,
            g.escaped
          );
          continue;
        }
        case "table": {
          for (m = "", h = "", o = g.header.length, l = 0; l < o; l++)
            h += this.renderer.tablecell(
              this.parseInline(g.header[l].tokens),
              { header: !0, align: g.align[l] }
            );
          for (m += this.renderer.tablerow(h), v = "", o = g.rows.length, l = 0; l < o; l++) {
            for (f = g.rows[l], h = "", c = f.length, r = 0; r < c; r++)
              h += this.renderer.tablecell(
                this.parseInline(f[r].tokens),
                { header: !1, align: g.align[r] }
              );
            v += this.renderer.tablerow(h);
          }
          n += this.renderer.table(m, v);
          continue;
        }
        case "blockquote": {
          v = this.parse(g.tokens), n += this.renderer.blockquote(v);
          continue;
        }
        case "list": {
          for ($ = g.ordered, b = g.start, k = g.loose, o = g.items.length, v = "", l = 0; l < o; l++)
            w = g.items[l], S = w.checked, C = w.task, p = "", w.task && (A = this.renderer.checkbox(S), k ? w.tokens.length > 0 && w.tokens[0].type === "paragraph" ? (w.tokens[0].text = A + " " + w.tokens[0].text, w.tokens[0].tokens && w.tokens[0].tokens.length > 0 && w.tokens[0].tokens[0].type === "text" && (w.tokens[0].tokens[0].text = A + " " + w.tokens[0].tokens[0].text)) : w.tokens.unshift({
              type: "text",
              text: A
            }) : p += A), p += this.parse(w.tokens, k), v += this.renderer.listitem(p, C, S);
          n += this.renderer.list(v, $, b);
          continue;
        }
        case "html": {
          n += this.renderer.html(g.text);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(this.parseInline(g.tokens));
          continue;
        }
        case "text": {
          for (v = g.tokens ? this.parseInline(g.tokens) : g.text; i + 1 < T && e[i + 1].type === "text"; )
            g = e[++i], v += `
` + (g.tokens ? this.parseInline(g.tokens) : g.text);
          n += t ? this.renderer.paragraph(v) : v;
          continue;
        }
        default: {
          const y = 'Token with "' + g.type + '" type was not found.';
          if (this.options.silent) {
            console.error(y);
            return;
          } else
            throw new Error(y);
        }
      }
    }
    return n;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(e, t) {
    t = t || this.renderer;
    let n = "", i, l, r;
    const o = e.length;
    for (i = 0; i < o; i++) {
      if (l = e[i], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[l.type] && (r = this.options.extensions.renderers[l.type].call({ parser: this }, l), r !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(l.type))) {
        n += r || "";
        continue;
      }
      switch (l.type) {
        case "escape": {
          n += t.text(l.text);
          break;
        }
        case "html": {
          n += t.html(l.text);
          break;
        }
        case "link": {
          n += t.link(l.href, l.title, this.parseInline(l.tokens, t));
          break;
        }
        case "image": {
          n += t.image(l.href, l.title, l.text);
          break;
        }
        case "strong": {
          n += t.strong(this.parseInline(l.tokens, t));
          break;
        }
        case "em": {
          n += t.em(this.parseInline(l.tokens, t));
          break;
        }
        case "codespan": {
          n += t.codespan(l.text);
          break;
        }
        case "br": {
          n += t.br();
          break;
        }
        case "del": {
          n += t.del(this.parseInline(l.tokens, t));
          break;
        }
        case "text": {
          n += t.text(l.text);
          break;
        }
        default: {
          const c = 'Token with "' + l.type + '" type was not found.';
          if (this.options.silent) {
            console.error(c);
            return;
          } else
            throw new Error(c);
        }
      }
    }
    return n;
  }
}
function z(s, e, t) {
  if (typeof s > "u" || s === null)
    throw new Error("marked(): input parameter is undefined or null");
  if (typeof s != "string")
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(s) + ", string expected");
  if (typeof e == "function" && (t = e, e = null), e = Ae({}, z.defaults, e || {}), qn(e), t) {
    const i = e.highlight;
    let l;
    try {
      l = Ue.lex(s, e);
    } catch (c) {
      return t(c);
    }
    const r = function(c) {
      let f;
      if (!c)
        try {
          e.walkTokens && z.walkTokens(l, e.walkTokens), f = De.parse(l, e);
        } catch (h) {
          c = h;
        }
      return e.highlight = i, c ? t(c) : t(null, f);
    };
    if (!i || i.length < 3 || (delete e.highlight, !l.length))
      return r();
    let o = 0;
    z.walkTokens(l, function(c) {
      c.type === "code" && (o++, setTimeout(() => {
        i(c.text, c.lang, function(f, h) {
          if (f)
            return r(f);
          h != null && h !== c.text && (c.text = h, c.escaped = !0), o--, o === 0 && r();
        });
      }, 0));
    }), o === 0 && r();
    return;
  }
  function n(i) {
    if (i.message += `
Please report this to https://github.com/markedjs/marked.`, e.silent)
      return "<p>An error occurred:</p><pre>" + fe(i.message + "", !0) + "</pre>";
    throw i;
  }
  try {
    const i = Ue.lex(s, e);
    if (e.walkTokens) {
      if (e.async)
        return Promise.all(z.walkTokens(i, e.walkTokens)).then(() => De.parse(i, e)).catch(n);
      z.walkTokens(i, e.walkTokens);
    }
    return De.parse(i, e);
  } catch (i) {
    n(i);
  }
}
z.options = z.setOptions = function(s) {
  return Ae(z.defaults, s), ji(z.defaults), z;
};
z.getDefaults = Mn;
z.defaults = mt;
z.use = function(...s) {
  const e = z.defaults.extensions || { renderers: {}, childTokens: {} };
  s.forEach((t) => {
    const n = Ae({}, t);
    if (n.async = z.defaults.async || n.async, t.extensions && (t.extensions.forEach((i) => {
      if (!i.name)
        throw new Error("extension name required");
      if (i.renderer) {
        const l = e.renderers[i.name];
        l ? e.renderers[i.name] = function(...r) {
          let o = i.renderer.apply(this, r);
          return o === !1 && (o = l.apply(this, r)), o;
        } : e.renderers[i.name] = i.renderer;
      }
      if (i.tokenizer) {
        if (!i.level || i.level !== "block" && i.level !== "inline")
          throw new Error("extension level must be 'block' or 'inline'");
        e[i.level] ? e[i.level].unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
      }
      i.childTokens && (e.childTokens[i.name] = i.childTokens);
    }), n.extensions = e), t.renderer) {
      const i = z.defaults.renderer || new un();
      for (const l in t.renderer) {
        const r = i[l];
        i[l] = (...o) => {
          let c = t.renderer[l].apply(i, o);
          return c === !1 && (c = r.apply(i, o)), c;
        };
      }
      n.renderer = i;
    }
    if (t.tokenizer) {
      const i = z.defaults.tokenizer || new cn();
      for (const l in t.tokenizer) {
        const r = i[l];
        i[l] = (...o) => {
          let c = t.tokenizer[l].apply(i, o);
          return c === !1 && (c = r.apply(i, o)), c;
        };
      }
      n.tokenizer = i;
    }
    if (t.walkTokens) {
      const i = z.defaults.walkTokens;
      n.walkTokens = function(l) {
        let r = [];
        return r.push(t.walkTokens.call(this, l)), i && (r = r.concat(i.call(this, l))), r;
      };
    }
    z.setOptions(n);
  });
};
z.walkTokens = function(s, e) {
  let t = [];
  for (const n of s)
    switch (t = t.concat(e.call(z, n)), n.type) {
      case "table": {
        for (const i of n.header)
          t = t.concat(z.walkTokens(i.tokens, e));
        for (const i of n.rows)
          for (const l of i)
            t = t.concat(z.walkTokens(l.tokens, e));
        break;
      }
      case "list": {
        t = t.concat(z.walkTokens(n.items, e));
        break;
      }
      default:
        z.defaults.extensions && z.defaults.extensions.childTokens && z.defaults.extensions.childTokens[n.type] ? z.defaults.extensions.childTokens[n.type].forEach(function(i) {
          t = t.concat(z.walkTokens(n[i], e));
        }) : n.tokens && (t = t.concat(z.walkTokens(n.tokens, e)));
    }
  return t;
};
z.parseInline = function(s, e) {
  if (typeof s > "u" || s === null)
    throw new Error("marked.parseInline(): input parameter is undefined or null");
  if (typeof s != "string")
    throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(s) + ", string expected");
  e = Ae({}, z.defaults, e || {}), qn(e);
  try {
    const t = Ue.lexInline(s, e);
    return e.walkTokens && z.walkTokens(t, e.walkTokens), De.parseInline(t, e);
  } catch (t) {
    if (t.message += `
Please report this to https://github.com/markedjs/marked.`, e.silent)
      return "<p>An error occurred:</p><pre>" + fe(t.message + "", !0) + "</pre>";
    throw t;
  }
};
z.Parser = De;
z.parser = De.parse;
z.Renderer = un;
z.TextRenderer = Vn;
z.Lexer = Ue;
z.lexer = Ue.lex;
z.Tokenizer = cn;
z.Slugger = Wn;
z.parse = z;
z.options;
z.setOptions;
z.use;
z.walkTokens;
z.parseInline;
De.parse;
Ue.lex;
var Ji = function() {
  var s = document.getSelection();
  if (!s.rangeCount)
    return function() {
    };
  for (var e = document.activeElement, t = [], n = 0; n < s.rangeCount; n++)
    t.push(s.getRangeAt(n));
  switch (e.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      e.blur();
      break;
    default:
      e = null;
      break;
  }
  return s.removeAllRanges(), function() {
    s.type === "Caret" && s.removeAllRanges(), s.rangeCount || t.forEach(function(i) {
      s.addRange(i);
    }), e && e.focus();
  };
}, es = Ji, Ln = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, ts = "Copy to clipboard: #{key}, Enter";
function ns(s) {
  var e = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return s.replace(/#{\s*key\s*}/g, e);
}
function is(s, e) {
  var t, n, i, l, r, o, c = !1;
  e || (e = {}), t = e.debug || !1;
  try {
    i = es(), l = document.createRange(), r = document.getSelection(), o = document.createElement("span"), o.textContent = s, o.ariaHidden = "true", o.style.all = "unset", o.style.position = "fixed", o.style.top = 0, o.style.clip = "rect(0, 0, 0, 0)", o.style.whiteSpace = "pre", o.style.webkitUserSelect = "text", o.style.MozUserSelect = "text", o.style.msUserSelect = "text", o.style.userSelect = "text", o.addEventListener("copy", function(h) {
      if (h.stopPropagation(), e.format)
        if (h.preventDefault(), typeof h.clipboardData > "u") {
          t && console.warn("unable to use e.clipboardData"), t && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var m = Ln[e.format] || Ln.default;
          window.clipboardData.setData(m, s);
        } else
          h.clipboardData.clearData(), h.clipboardData.setData(e.format, s);
      e.onCopy && (h.preventDefault(), e.onCopy(h.clipboardData));
    }), document.body.appendChild(o), l.selectNodeContents(o), r.addRange(l);
    var f = document.execCommand("copy");
    if (!f)
      throw new Error("copy command was unsuccessful");
    c = !0;
  } catch (h) {
    t && console.error("unable to copy using execCommand: ", h), t && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(e.format || "text", s), e.onCopy && e.onCopy(window.clipboardData), c = !0;
    } catch (m) {
      t && console.error("unable to copy using clipboardData: ", m), t && console.error("falling back to prompt"), n = ns("message" in e ? e.message : ts), window.prompt(n, s);
    }
  } finally {
    r && (typeof r.removeRange == "function" ? r.removeRange(l) : r.removeAllRanges()), o && document.body.removeChild(o), i();
  }
  return c;
}
var bt = is;
/*! medium-zoom 1.0.8 | MIT License | https://github.com/francoischalifour/medium-zoom */
var Ye = Object.assign || function(s) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e];
    for (var n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (s[n] = t[n]);
  }
  return s;
}, Rt = function(e) {
  return e.tagName === "IMG";
}, ss = function(e) {
  return NodeList.prototype.isPrototypeOf(e);
}, Dt = function(e) {
  return e && e.nodeType === 1;
}, Fn = function(e) {
  var t = e.currentSrc || e.src;
  return t.substr(-4).toLowerCase() === ".svg";
}, Rn = function(e) {
  try {
    return Array.isArray(e) ? e.filter(Rt) : ss(e) ? [].slice.call(e).filter(Rt) : Dt(e) ? [e].filter(Rt) : typeof e == "string" ? [].slice.call(document.querySelectorAll(e)).filter(Rt) : [];
  } catch {
    throw new TypeError(`The provided selector is invalid.
Expects a CSS selector, a Node element, a NodeList or an array.
See: https://github.com/francoischalifour/medium-zoom`);
  }
}, ls = function(e) {
  var t = document.createElement("div");
  return t.classList.add("medium-zoom-overlay"), t.style.background = e, t;
}, os = function(e) {
  var t = e.getBoundingClientRect(), n = t.top, i = t.left, l = t.width, r = t.height, o = e.cloneNode(), c = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, f = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
  return o.removeAttribute("id"), o.style.position = "absolute", o.style.top = n + c + "px", o.style.left = i + f + "px", o.style.width = l + "px", o.style.height = r + "px", o.style.transform = "", o;
}, lt = function(e, t) {
  var n = Ye({
    bubbles: !1,
    cancelable: !1,
    detail: void 0
  }, t);
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(e, n);
  var i = document.createEvent("CustomEvent");
  return i.initCustomEvent(e, n.bubbles, n.cancelable, n.detail), i;
}, rs = function s(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = window.Promise || function(_) {
    function O() {
    }
    _(O, O);
  }, i = function(_) {
    var O = _.target;
    if (O === X) {
      $();
      return;
    }
    S.indexOf(O) !== -1 && b({ target: O });
  }, l = function() {
    if (!(A || !y.original)) {
      var _ = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      Math.abs(M - _) > T.scrollOffset && setTimeout($, 150);
    }
  }, r = function(_) {
    var O = _.key || _.keyCode;
    (O === "Escape" || O === "Esc" || O === 27) && $();
  }, o = function() {
    var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, O = _;
    if (_.background && (X.style.background = _.background), _.container && _.container instanceof Object && (O.container = Ye({}, T.container, _.container)), _.template) {
      var B = Dt(_.template) ? _.template : document.querySelector(_.template);
      O.template = B;
    }
    return T = Ye({}, T, O), S.forEach(function(W) {
      W.dispatchEvent(lt("medium-zoom:update", {
        detail: { zoom: V }
      }));
    }), V;
  }, c = function() {
    var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return s(Ye({}, T, _));
  }, f = function() {
    for (var _ = arguments.length, O = Array(_), B = 0; B < _; B++)
      O[B] = arguments[B];
    var W = O.reduce(function(H, se) {
      return [].concat(H, Rn(se));
    }, []);
    return W.filter(function(H) {
      return S.indexOf(H) === -1;
    }).forEach(function(H) {
      S.push(H), H.classList.add("medium-zoom-image");
    }), C.forEach(function(H) {
      var se = H.type, F = H.listener, D = H.options;
      W.forEach(function(N) {
        N.addEventListener(se, F, D);
      });
    }), V;
  }, h = function() {
    for (var _ = arguments.length, O = Array(_), B = 0; B < _; B++)
      O[B] = arguments[B];
    y.zoomed && $();
    var W = O.length > 0 ? O.reduce(function(H, se) {
      return [].concat(H, Rn(se));
    }, []) : S;
    return W.forEach(function(H) {
      H.classList.remove("medium-zoom-image"), H.dispatchEvent(lt("medium-zoom:detach", {
        detail: { zoom: V }
      }));
    }), S = S.filter(function(H) {
      return W.indexOf(H) === -1;
    }), V;
  }, m = function(_, O) {
    var B = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return S.forEach(function(W) {
      W.addEventListener("medium-zoom:" + _, O, B);
    }), C.push({ type: "medium-zoom:" + _, listener: O, options: B }), V;
  }, v = function(_, O) {
    var B = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return S.forEach(function(W) {
      W.removeEventListener("medium-zoom:" + _, O, B);
    }), C = C.filter(function(W) {
      return !(W.type === "medium-zoom:" + _ && W.listener.toString() === O.toString());
    }), V;
  }, g = function() {
    var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, O = _.target, B = function() {
      var H = {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }, se = void 0, F = void 0;
      if (T.container)
        if (T.container instanceof Object)
          H = Ye({}, H, T.container), se = H.width - H.left - H.right - T.margin * 2, F = H.height - H.top - H.bottom - T.margin * 2;
        else {
          var D = Dt(T.container) ? T.container : document.querySelector(T.container), N = D.getBoundingClientRect(), ce = N.width, de = N.height, ve = N.left, Ie = N.top;
          H = Ye({}, H, {
            width: ce,
            height: de,
            left: ve,
            top: Ie
          });
        }
      se = se || H.width - T.margin * 2, F = F || H.height - T.margin * 2;
      var He = y.zoomedHd || y.original, Xe = Fn(He) ? se : He.naturalWidth || se, qe = Fn(He) ? F : He.naturalHeight || F, Qe = He.getBoundingClientRect(), Tt = Qe.top, Et = Qe.left, nt = Qe.width, it = Qe.height, zt = Math.min(Math.max(nt, Xe), se) / nt, _t = Math.min(Math.max(it, qe), F) / it, st = Math.min(zt, _t), At = (-Et + (se - nt) / 2 + T.margin + H.left) / st, It = (-Tt + (F - it) / 2 + T.margin + H.top) / st, gt = "scale(" + st + ") translate3d(" + At + "px, " + It + "px, 0)";
      y.zoomed.style.transform = gt, y.zoomedHd && (y.zoomedHd.style.transform = gt);
    };
    return new n(function(W) {
      if (O && S.indexOf(O) === -1) {
        W(V);
        return;
      }
      var H = function ce() {
        A = !1, y.zoomed.removeEventListener("transitionend", ce), y.original.dispatchEvent(lt("medium-zoom:opened", {
          detail: { zoom: V }
        })), W(V);
      };
      if (y.zoomed) {
        W(V);
        return;
      }
      if (O)
        y.original = O;
      else if (S.length > 0) {
        var se = S;
        y.original = se[0];
      } else {
        W(V);
        return;
      }
      if (y.original.dispatchEvent(lt("medium-zoom:open", {
        detail: { zoom: V }
      })), M = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, A = !0, y.zoomed = os(y.original), document.body.appendChild(X), T.template) {
        var F = Dt(T.template) ? T.template : document.querySelector(T.template);
        y.template = document.createElement("div"), y.template.appendChild(F.content.cloneNode(!0)), document.body.appendChild(y.template);
      }
      if (y.original.parentElement && y.original.parentElement.tagName === "PICTURE" && y.original.currentSrc && (y.zoomed.src = y.original.currentSrc), document.body.appendChild(y.zoomed), window.requestAnimationFrame(function() {
        document.body.classList.add("medium-zoom--opened");
      }), y.original.classList.add("medium-zoom-image--hidden"), y.zoomed.classList.add("medium-zoom-image--opened"), y.zoomed.addEventListener("click", $), y.zoomed.addEventListener("transitionend", H), y.original.getAttribute("data-zoom-src")) {
        y.zoomedHd = y.zoomed.cloneNode(), y.zoomedHd.removeAttribute("srcset"), y.zoomedHd.removeAttribute("sizes"), y.zoomedHd.removeAttribute("loading"), y.zoomedHd.src = y.zoomed.getAttribute("data-zoom-src"), y.zoomedHd.onerror = function() {
          clearInterval(D), console.warn("Unable to reach the zoom image target " + y.zoomedHd.src), y.zoomedHd = null, B();
        };
        var D = setInterval(function() {
          y.zoomedHd.complete && (clearInterval(D), y.zoomedHd.classList.add("medium-zoom-image--opened"), y.zoomedHd.addEventListener("click", $), document.body.appendChild(y.zoomedHd), B());
        }, 10);
      } else if (y.original.hasAttribute("srcset")) {
        y.zoomedHd = y.zoomed.cloneNode(), y.zoomedHd.removeAttribute("sizes"), y.zoomedHd.removeAttribute("loading");
        var N = y.zoomedHd.addEventListener("load", function() {
          y.zoomedHd.removeEventListener("load", N), y.zoomedHd.classList.add("medium-zoom-image--opened"), y.zoomedHd.addEventListener("click", $), document.body.appendChild(y.zoomedHd), B();
        });
      } else
        B();
    });
  }, $ = function() {
    return new n(function(_) {
      if (A || !y.original) {
        _(V);
        return;
      }
      var O = function B() {
        y.original.classList.remove("medium-zoom-image--hidden"), document.body.removeChild(y.zoomed), y.zoomedHd && document.body.removeChild(y.zoomedHd), document.body.removeChild(X), y.zoomed.classList.remove("medium-zoom-image--opened"), y.template && document.body.removeChild(y.template), A = !1, y.zoomed.removeEventListener("transitionend", B), y.original.dispatchEvent(lt("medium-zoom:closed", {
          detail: { zoom: V }
        })), y.original = null, y.zoomed = null, y.zoomedHd = null, y.template = null, _(V);
      };
      A = !0, document.body.classList.remove("medium-zoom--opened"), y.zoomed.style.transform = "", y.zoomedHd && (y.zoomedHd.style.transform = ""), y.template && (y.template.style.transition = "opacity 150ms", y.template.style.opacity = 0), y.original.dispatchEvent(lt("medium-zoom:close", {
        detail: { zoom: V }
      })), y.zoomed.addEventListener("transitionend", O);
    });
  }, b = function() {
    var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, O = _.target;
    return y.original ? $() : g({ target: O });
  }, k = function() {
    return T;
  }, p = function() {
    return S;
  }, w = function() {
    return y.original;
  }, S = [], C = [], A = !1, M = 0, T = t, y = {
    original: null,
    zoomed: null,
    zoomedHd: null,
    template: null
    // If the selector is omitted, it's replaced by the options
  };
  Object.prototype.toString.call(e) === "[object Object]" ? T = e : (e || typeof e == "string") && f(e), T = Ye({
    margin: 0,
    background: "#fff",
    scrollOffset: 40,
    container: null,
    template: null
  }, T);
  var X = ls(T.background);
  document.addEventListener("click", i), document.addEventListener("keyup", r), document.addEventListener("scroll", l), window.addEventListener("resize", $);
  var V = {
    open: g,
    close: $,
    toggle: b,
    update: o,
    clone: c,
    attach: f,
    detach: h,
    on: m,
    off: v,
    getOptions: k,
    getImages: p,
    getZoomedImage: w
  };
  return V;
};
function as(s, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(!s || typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style");
    i.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(i, n.firstChild) : n.appendChild(i), i.styleSheet ? i.styleSheet.cssText = s : i.appendChild(document.createTextNode(s));
  }
}
var cs = ".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";
as(cs);
const us = rs, pt = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, Kn = /* @__PURE__ */ new Set(), ds = (s, e, t, n) => {
  typeof process == "object" && process && typeof process.emitWarning == "function" ? process.emitWarning(s, e, t, n) : console.error(`[${t}] ${e}: ${s}`);
}, hs = (s) => !Kn.has(s), Ve = (s) => s && s === Math.floor(s) && s > 0 && isFinite(s), Gn = (s) => Ve(s) ? s <= Math.pow(2, 8) ? Uint8Array : s <= Math.pow(2, 16) ? Uint16Array : s <= Math.pow(2, 32) ? Uint32Array : s <= Number.MAX_SAFE_INTEGER ? Ht : null : null;
class Ht extends Array {
  constructor(e) {
    super(e), this.fill(0);
  }
}
var at;
const rt = class {
  constructor(e, t) {
    le(this, "heap");
    le(this, "length");
    if (!a(rt, at))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new t(e), this.length = 0;
  }
  static create(e) {
    const t = Gn(e);
    if (!t)
      return [];
    R(rt, at, !0);
    const n = new rt(e, t);
    return R(rt, at, !1), n;
  }
  push(e) {
    this.heap[this.length++] = e;
  }
  pop() {
    return this.heap[--this.length];
  }
};
let jt = rt;
at = new WeakMap(), // private constructor
P(jt, at, !1);
var $e, be, Le, Se, ct, oe, Ce, re, Q, j, ge, ke, me, ue, Te, he, Me, Be, Ee, Fe, Ge, pe, yt, en, Je, Ne, wt, ye, Wt, Zn, et, ut, xt, Re, We, Oe, Ke, $t, tn, dt, Pt, ht, Mt, Y, ee, St, nn, tt, kt;
const dn = class {
  constructor(e) {
    P(this, yt);
    P(this, Wt);
    P(this, Re);
    P(this, Oe);
    P(this, $t);
    P(this, dt);
    P(this, ht);
    P(this, Y);
    P(this, St);
    P(this, tt);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    P(this, $e, void 0);
    P(this, be, void 0);
    P(this, Le, void 0);
    P(this, Se, void 0);
    P(this, ct, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    le(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    le(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    le(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    le(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    le(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    le(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    le(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    le(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    le(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    le(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    le(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    le(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    le(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    le(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    le(this, "ignoreFetchAbort");
    // computed properties
    P(this, oe, void 0);
    P(this, Ce, void 0);
    P(this, re, void 0);
    P(this, Q, void 0);
    P(this, j, void 0);
    P(this, ge, void 0);
    P(this, ke, void 0);
    P(this, me, void 0);
    P(this, ue, void 0);
    P(this, Te, void 0);
    P(this, he, void 0);
    P(this, Me, void 0);
    P(this, Be, void 0);
    P(this, Ee, void 0);
    P(this, Fe, void 0);
    P(this, Ge, void 0);
    P(this, pe, void 0);
    // conditionally set private methods related to TTL
    P(this, Je, () => {
    });
    P(this, Ne, () => {
    });
    P(this, wt, () => {
    });
    /* c8 ignore stop */
    P(this, ye, () => !1);
    P(this, et, (e) => {
    });
    P(this, ut, (e, t, n) => {
    });
    P(this, xt, (e, t, n, i) => {
      if (n || i)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    });
    const { max: t = 0, ttl: n, ttlResolution: i = 1, ttlAutopurge: l, updateAgeOnGet: r, updateAgeOnHas: o, allowStale: c, dispose: f, disposeAfter: h, noDisposeOnSet: m, noUpdateTTL: v, maxSize: g = 0, maxEntrySize: $ = 0, sizeCalculation: b, fetchMethod: k, noDeleteOnFetchRejection: p, noDeleteOnStaleGet: w, allowStaleOnFetchRejection: S, allowStaleOnFetchAbort: C, ignoreFetchAbort: A } = e;
    if (t !== 0 && !Ve(t))
      throw new TypeError("max option must be a nonnegative integer");
    const M = t ? Gn(t) : Array;
    if (!M)
      throw new Error("invalid max value: " + t);
    if (R(this, $e, t), R(this, be, g), this.maxEntrySize = $ || a(this, be), this.sizeCalculation = b, this.sizeCalculation) {
      if (!a(this, be) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (k !== void 0 && typeof k != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (R(this, ct, k), R(this, Ge, !!k), R(this, re, /* @__PURE__ */ new Map()), R(this, Q, new Array(t).fill(void 0)), R(this, j, new Array(t).fill(void 0)), R(this, ge, new M(t)), R(this, ke, new M(t)), R(this, me, 0), R(this, ue, 0), R(this, Te, jt.create(t)), R(this, oe, 0), R(this, Ce, 0), typeof f == "function" && R(this, Le, f), typeof h == "function" ? (R(this, Se, h), R(this, he, [])) : (R(this, Se, void 0), R(this, he, void 0)), R(this, Fe, !!a(this, Le)), R(this, pe, !!a(this, Se)), this.noDisposeOnSet = !!m, this.noUpdateTTL = !!v, this.noDeleteOnFetchRejection = !!p, this.allowStaleOnFetchRejection = !!S, this.allowStaleOnFetchAbort = !!C, this.ignoreFetchAbort = !!A, this.maxEntrySize !== 0) {
      if (a(this, be) !== 0 && !Ve(a(this, be)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!Ve(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      I(this, Wt, Zn).call(this);
    }
    if (this.allowStale = !!c, this.noDeleteOnStaleGet = !!w, this.updateAgeOnGet = !!r, this.updateAgeOnHas = !!o, this.ttlResolution = Ve(i) || i === 0 ? i : 1, this.ttlAutopurge = !!l, this.ttl = n || 0, this.ttl) {
      if (!Ve(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      I(this, yt, en).call(this);
    }
    if (a(this, $e) === 0 && this.ttl === 0 && a(this, be) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !a(this, $e) && !a(this, be)) {
      const T = "LRU_CACHE_UNBOUNDED";
      hs(T) && (Kn.add(T), ds("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", T, dn));
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(e) {
    return {
      // properties
      starts: a(e, Be),
      ttls: a(e, Ee),
      sizes: a(e, Me),
      keyMap: a(e, re),
      keyList: a(e, Q),
      valList: a(e, j),
      next: a(e, ge),
      prev: a(e, ke),
      get head() {
        return a(e, me);
      },
      get tail() {
        return a(e, ue);
      },
      free: a(e, Te),
      // methods
      isBackgroundFetch: (t) => {
        var n;
        return I(n = e, Y, ee).call(n, t);
      },
      backgroundFetch: (t, n, i, l) => {
        var r;
        return I(r = e, ht, Mt).call(r, t, n, i, l);
      },
      moveToTail: (t) => {
        var n;
        return I(n = e, tt, kt).call(n, t);
      },
      indexes: (t) => {
        var n;
        return I(n = e, Re, We).call(n, t);
      },
      rindexes: (t) => {
        var n;
        return I(n = e, Oe, Ke).call(n, t);
      },
      isStale: (t) => {
        var n;
        return a(n = e, ye).call(n, t);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return a(this, $e);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return a(this, be);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return a(this, Ce);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return a(this, oe);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return a(this, ct);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return a(this, Le);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return a(this, Se);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(e) {
    return a(this, re).has(e) ? 1 / 0 : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const e of I(this, Re, We).call(this))
      a(this, j)[e] !== void 0 && a(this, Q)[e] !== void 0 && !I(this, Y, ee).call(this, a(this, j)[e]) && (yield [a(this, Q)[e], a(this, j)[e]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const e of I(this, Oe, Ke).call(this))
      a(this, j)[e] !== void 0 && a(this, Q)[e] !== void 0 && !I(this, Y, ee).call(this, a(this, j)[e]) && (yield [a(this, Q)[e], a(this, j)[e]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const e of I(this, Re, We).call(this)) {
      const t = a(this, Q)[e];
      t !== void 0 && !I(this, Y, ee).call(this, a(this, j)[e]) && (yield t);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const e of I(this, Oe, Ke).call(this)) {
      const t = a(this, Q)[e];
      t !== void 0 && !I(this, Y, ee).call(this, a(this, j)[e]) && (yield t);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const e of I(this, Re, We).call(this))
      a(this, j)[e] !== void 0 && !I(this, Y, ee).call(this, a(this, j)[e]) && (yield a(this, j)[e]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const e of I(this, Oe, Ke).call(this))
      a(this, j)[e] !== void 0 && !I(this, Y, ee).call(this, a(this, j)[e]) && (yield a(this, j)[e]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(e, t = {}) {
    for (const n of I(this, Re, We).call(this)) {
      const i = a(this, j)[n], l = I(this, Y, ee).call(this, i) ? i.__staleWhileFetching : i;
      if (l !== void 0 && e(l, a(this, Q)[n], this))
        return this.get(a(this, Q)[n], t);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(e, t = this) {
    for (const n of I(this, Re, We).call(this)) {
      const i = a(this, j)[n], l = I(this, Y, ee).call(this, i) ? i.__staleWhileFetching : i;
      l !== void 0 && e.call(t, l, a(this, Q)[n], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(e, t = this) {
    for (const n of I(this, Oe, Ke).call(this)) {
      const i = a(this, j)[n], l = I(this, Y, ee).call(this, i) ? i.__staleWhileFetching : i;
      l !== void 0 && e.call(t, l, a(this, Q)[n], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let e = !1;
    for (const t of I(this, Oe, Ke).call(this, { allowStale: !0 }))
      a(this, ye).call(this, t) && (this.delete(a(this, Q)[t]), e = !0);
    return e;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const e = [];
    for (const t of I(this, Re, We).call(this, { allowStale: !0 })) {
      const n = a(this, Q)[t], i = a(this, j)[t], l = I(this, Y, ee).call(this, i) ? i.__staleWhileFetching : i;
      if (l === void 0 || n === void 0)
        continue;
      const r = { value: l };
      if (a(this, Ee) && a(this, Be)) {
        r.ttl = a(this, Ee)[t];
        const o = pt.now() - a(this, Be)[t];
        r.start = Math.floor(Date.now() - o);
      }
      a(this, Me) && (r.size = a(this, Me)[t]), e.unshift([n, r]);
    }
    return e;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(e) {
    this.clear();
    for (const [t, n] of e) {
      if (n.start) {
        const i = Date.now() - n.start;
        n.start = pt.now() - i;
      }
      this.set(t, n.value, n);
    }
  }
  /**
   * Add a value to the cache.
   */
  set(e, t, n = {}) {
    var v, g, $;
    const { ttl: i = this.ttl, start: l, noDisposeOnSet: r = this.noDisposeOnSet, sizeCalculation: o = this.sizeCalculation, status: c } = n;
    let { noUpdateTTL: f = this.noUpdateTTL } = n;
    const h = a(this, xt).call(this, e, t, n.size || 0, o);
    if (this.maxEntrySize && h > this.maxEntrySize)
      return c && (c.set = "miss", c.maxEntrySizeExceeded = !0), this.delete(e), this;
    let m = a(this, oe) === 0 ? void 0 : a(this, re).get(e);
    if (m === void 0)
      m = a(this, oe) === 0 ? a(this, ue) : a(this, Te).length !== 0 ? a(this, Te).pop() : a(this, oe) === a(this, $e) ? I(this, dt, Pt).call(this, !1) : a(this, oe), a(this, Q)[m] = e, a(this, j)[m] = t, a(this, re).set(e, m), a(this, ge)[a(this, ue)] = m, a(this, ke)[m] = a(this, ue), R(this, ue, m), Lt(this, oe)._++, a(this, ut).call(this, m, h, c), c && (c.set = "add"), f = !1;
    else {
      I(this, tt, kt).call(this, m);
      const b = a(this, j)[m];
      if (t !== b) {
        if (a(this, Ge) && I(this, Y, ee).call(this, b) ? b.__abortController.abort(new Error("replaced")) : r || (a(this, Fe) && ((v = a(this, Le)) == null || v.call(this, b, e, "set")), a(this, pe) && ((g = a(this, he)) == null || g.push([b, e, "set"]))), a(this, et).call(this, m), a(this, ut).call(this, m, h, c), a(this, j)[m] = t, c) {
          c.set = "replace";
          const k = b && I(this, Y, ee).call(this, b) ? b.__staleWhileFetching : b;
          k !== void 0 && (c.oldValue = k);
        }
      } else
        c && (c.set = "update");
    }
    if (i !== 0 && !a(this, Ee) && I(this, yt, en).call(this), a(this, Ee) && (f || a(this, wt).call(this, m, i, l), c && a(this, Ne).call(this, c, m)), !r && a(this, pe) && a(this, he)) {
      const b = a(this, he);
      let k;
      for (; k = b == null ? void 0 : b.shift(); )
        ($ = a(this, Se)) == null || $.call(this, ...k);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var e;
    try {
      for (; a(this, oe); ) {
        const t = a(this, j)[a(this, me)];
        if (I(this, dt, Pt).call(this, !0), I(this, Y, ee).call(this, t)) {
          if (t.__staleWhileFetching)
            return t.__staleWhileFetching;
        } else if (t !== void 0)
          return t;
      }
    } finally {
      if (a(this, pe) && a(this, he)) {
        const t = a(this, he);
        let n;
        for (; n = t == null ? void 0 : t.shift(); )
          (e = a(this, Se)) == null || e.call(this, ...n);
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(e, t = {}) {
    const { updateAgeOnHas: n = this.updateAgeOnHas, status: i } = t, l = a(this, re).get(e);
    if (l !== void 0)
      if (a(this, ye).call(this, l))
        i && (i.has = "stale", a(this, Ne).call(this, i, l));
      else
        return n && a(this, Je).call(this, l), i && (i.has = "hit", a(this, Ne).call(this, i, l)), !0;
    else
      i && (i.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(e, t = {}) {
    const { allowStale: n = this.allowStale } = t, i = a(this, re).get(e);
    if (i !== void 0 && (n || !a(this, ye).call(this, i))) {
      const l = a(this, j)[i];
      return I(this, Y, ee).call(this, l) ? l.__staleWhileFetching : l;
    }
  }
  async fetch(e, t = {}) {
    const {
      // get options
      allowStale: n = this.allowStale,
      updateAgeOnGet: i = this.updateAgeOnGet,
      noDeleteOnStaleGet: l = this.noDeleteOnStaleGet,
      // set options
      ttl: r = this.ttl,
      noDisposeOnSet: o = this.noDisposeOnSet,
      size: c = 0,
      sizeCalculation: f = this.sizeCalculation,
      noUpdateTTL: h = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: m = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: v = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: g = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: $ = this.allowStaleOnFetchAbort,
      context: b,
      forceRefresh: k = !1,
      status: p,
      signal: w
    } = t;
    if (!a(this, Ge))
      return p && (p.fetch = "get"), this.get(e, {
        allowStale: n,
        updateAgeOnGet: i,
        noDeleteOnStaleGet: l,
        status: p
      });
    const S = {
      allowStale: n,
      updateAgeOnGet: i,
      noDeleteOnStaleGet: l,
      ttl: r,
      noDisposeOnSet: o,
      size: c,
      sizeCalculation: f,
      noUpdateTTL: h,
      noDeleteOnFetchRejection: m,
      allowStaleOnFetchRejection: v,
      allowStaleOnFetchAbort: $,
      ignoreFetchAbort: g,
      status: p,
      signal: w
    };
    let C = a(this, re).get(e);
    if (C === void 0) {
      p && (p.fetch = "miss");
      const A = I(this, ht, Mt).call(this, e, C, S, b);
      return A.__returned = A;
    } else {
      const A = a(this, j)[C];
      if (I(this, Y, ee).call(this, A)) {
        const V = n && A.__staleWhileFetching !== void 0;
        return p && (p.fetch = "inflight", V && (p.returnedStale = !0)), V ? A.__staleWhileFetching : A.__returned = A;
      }
      const M = a(this, ye).call(this, C);
      if (!k && !M)
        return p && (p.fetch = "hit"), I(this, tt, kt).call(this, C), i && a(this, Je).call(this, C), p && a(this, Ne).call(this, p, C), A;
      const T = I(this, ht, Mt).call(this, e, C, S, b), X = T.__staleWhileFetching !== void 0 && n;
      return p && (p.fetch = M ? "stale" : "refresh", X && M && (p.returnedStale = !0)), X ? T.__staleWhileFetching : T.__returned = T;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(e, t = {}) {
    const { allowStale: n = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: l = this.noDeleteOnStaleGet, status: r } = t, o = a(this, re).get(e);
    if (o !== void 0) {
      const c = a(this, j)[o], f = I(this, Y, ee).call(this, c);
      return r && a(this, Ne).call(this, r, o), a(this, ye).call(this, o) ? (r && (r.get = "stale"), f ? (r && n && c.__staleWhileFetching !== void 0 && (r.returnedStale = !0), n ? c.__staleWhileFetching : void 0) : (l || this.delete(e), r && n && (r.returnedStale = !0), n ? c : void 0)) : (r && (r.get = "hit"), f ? c.__staleWhileFetching : (I(this, tt, kt).call(this, o), i && a(this, Je).call(this, o), c));
    } else
      r && (r.get = "miss");
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(e) {
    var n, i, l, r;
    let t = !1;
    if (a(this, oe) !== 0) {
      const o = a(this, re).get(e);
      if (o !== void 0)
        if (t = !0, a(this, oe) === 1)
          this.clear();
        else {
          a(this, et).call(this, o);
          const c = a(this, j)[o];
          I(this, Y, ee).call(this, c) ? c.__abortController.abort(new Error("deleted")) : (a(this, Fe) || a(this, pe)) && (a(this, Fe) && ((n = a(this, Le)) == null || n.call(this, c, e, "delete")), a(this, pe) && ((i = a(this, he)) == null || i.push([c, e, "delete"]))), a(this, re).delete(e), a(this, Q)[o] = void 0, a(this, j)[o] = void 0, o === a(this, ue) ? R(this, ue, a(this, ke)[o]) : o === a(this, me) ? R(this, me, a(this, ge)[o]) : (a(this, ge)[a(this, ke)[o]] = a(this, ge)[o], a(this, ke)[a(this, ge)[o]] = a(this, ke)[o]), Lt(this, oe)._--, a(this, Te).push(o);
        }
    }
    if (a(this, pe) && ((l = a(this, he)) != null && l.length)) {
      const o = a(this, he);
      let c;
      for (; c = o == null ? void 0 : o.shift(); )
        (r = a(this, Se)) == null || r.call(this, ...c);
    }
    return t;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var e, t, n;
    for (const i of I(this, Oe, Ke).call(this, { allowStale: !0 })) {
      const l = a(this, j)[i];
      if (I(this, Y, ee).call(this, l))
        l.__abortController.abort(new Error("deleted"));
      else {
        const r = a(this, Q)[i];
        a(this, Fe) && ((e = a(this, Le)) == null || e.call(this, l, r, "delete")), a(this, pe) && ((t = a(this, he)) == null || t.push([l, r, "delete"]));
      }
    }
    if (a(this, re).clear(), a(this, j).fill(void 0), a(this, Q).fill(void 0), a(this, Ee) && a(this, Be) && (a(this, Ee).fill(0), a(this, Be).fill(0)), a(this, Me) && a(this, Me).fill(0), R(this, me, 0), R(this, ue, 0), a(this, Te).length = 0, R(this, Ce, 0), R(this, oe, 0), a(this, pe) && a(this, he)) {
      const i = a(this, he);
      let l;
      for (; l = i == null ? void 0 : i.shift(); )
        (n = a(this, Se)) == null || n.call(this, ...l);
    }
  }
};
let Jt = dn;
$e = new WeakMap(), be = new WeakMap(), Le = new WeakMap(), Se = new WeakMap(), ct = new WeakMap(), oe = new WeakMap(), Ce = new WeakMap(), re = new WeakMap(), Q = new WeakMap(), j = new WeakMap(), ge = new WeakMap(), ke = new WeakMap(), me = new WeakMap(), ue = new WeakMap(), Te = new WeakMap(), he = new WeakMap(), Me = new WeakMap(), Be = new WeakMap(), Ee = new WeakMap(), Fe = new WeakMap(), Ge = new WeakMap(), pe = new WeakMap(), yt = new WeakSet(), en = function() {
  const e = new Ht(a(this, $e)), t = new Ht(a(this, $e));
  R(this, Ee, e), R(this, Be, t), R(this, wt, (l, r, o = pt.now()) => {
    if (t[l] = r !== 0 ? o : 0, e[l] = r, r !== 0 && this.ttlAutopurge) {
      const c = setTimeout(() => {
        a(this, ye).call(this, l) && this.delete(a(this, Q)[l]);
      }, r + 1);
      c.unref && c.unref();
    }
  }), R(this, Je, (l) => {
    t[l] = e[l] !== 0 ? pt.now() : 0;
  }), R(this, Ne, (l, r) => {
    if (e[r]) {
      const o = e[r], c = t[r];
      l.ttl = o, l.start = c, l.now = n || i(), l.remainingTTL = l.now + o - c;
    }
  });
  let n = 0;
  const i = () => {
    const l = pt.now();
    if (this.ttlResolution > 0) {
      n = l;
      const r = setTimeout(() => n = 0, this.ttlResolution);
      r.unref && r.unref();
    }
    return l;
  };
  this.getRemainingTTL = (l) => {
    const r = a(this, re).get(l);
    return r === void 0 ? 0 : e[r] === 0 || t[r] === 0 ? 1 / 0 : t[r] + e[r] - (n || i());
  }, R(this, ye, (l) => e[l] !== 0 && t[l] !== 0 && (n || i()) - t[l] > e[l]);
}, Je = new WeakMap(), Ne = new WeakMap(), wt = new WeakMap(), ye = new WeakMap(), Wt = new WeakSet(), Zn = function() {
  const e = new Ht(a(this, $e));
  R(this, Ce, 0), R(this, Me, e), R(this, et, (t) => {
    R(this, Ce, a(this, Ce) - e[t]), e[t] = 0;
  }), R(this, xt, (t, n, i, l) => {
    if (I(this, Y, ee).call(this, n))
      return 0;
    if (!Ve(i))
      if (l) {
        if (typeof l != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (i = l(n, t), !Ve(i))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return i;
  }), R(this, ut, (t, n, i) => {
    if (e[t] = n, a(this, be)) {
      const l = a(this, be) - e[t];
      for (; a(this, Ce) > l; )
        I(this, dt, Pt).call(this, !0);
    }
    R(this, Ce, a(this, Ce) + e[t]), i && (i.entrySize = n, i.totalCalculatedSize = a(this, Ce));
  });
}, et = new WeakMap(), ut = new WeakMap(), xt = new WeakMap(), Re = new WeakSet(), We = function* ({ allowStale: e = this.allowStale } = {}) {
  if (a(this, oe))
    for (let t = a(this, ue); !(!I(this, $t, tn).call(this, t) || ((e || !a(this, ye).call(this, t)) && (yield t), t === a(this, me))); )
      t = a(this, ke)[t];
}, Oe = new WeakSet(), Ke = function* ({ allowStale: e = this.allowStale } = {}) {
  if (a(this, oe))
    for (let t = a(this, me); !(!I(this, $t, tn).call(this, t) || ((e || !a(this, ye).call(this, t)) && (yield t), t === a(this, ue))); )
      t = a(this, ge)[t];
}, $t = new WeakSet(), tn = function(e) {
  return e !== void 0 && a(this, re).get(a(this, Q)[e]) === e;
}, dt = new WeakSet(), Pt = function(e) {
  var l, r;
  const t = a(this, me), n = a(this, Q)[t], i = a(this, j)[t];
  return a(this, Ge) && I(this, Y, ee).call(this, i) ? i.__abortController.abort(new Error("evicted")) : (a(this, Fe) || a(this, pe)) && (a(this, Fe) && ((l = a(this, Le)) == null || l.call(this, i, n, "evict")), a(this, pe) && ((r = a(this, he)) == null || r.push([i, n, "evict"]))), a(this, et).call(this, t), e && (a(this, Q)[t] = void 0, a(this, j)[t] = void 0, a(this, Te).push(t)), a(this, oe) === 1 ? (R(this, me, R(this, ue, 0)), a(this, Te).length = 0) : R(this, me, a(this, ge)[t]), a(this, re).delete(n), Lt(this, oe)._--, t;
}, ht = new WeakSet(), Mt = function(e, t, n, i) {
  const l = t === void 0 ? void 0 : a(this, j)[t];
  if (I(this, Y, ee).call(this, l))
    return l;
  const r = new AbortController(), { signal: o } = n;
  o == null || o.addEventListener("abort", () => r.abort(o.reason), {
    signal: r.signal
  });
  const c = {
    signal: r.signal,
    options: n,
    context: i
  }, f = (b, k = !1) => {
    const { aborted: p } = r.signal, w = n.ignoreFetchAbort && b !== void 0;
    if (n.status && (p && !k ? (n.status.fetchAborted = !0, n.status.fetchError = r.signal.reason, w && (n.status.fetchAbortIgnored = !0)) : n.status.fetchResolved = !0), p && !w && !k)
      return m(r.signal.reason);
    const S = g;
    return a(this, j)[t] === g && (b === void 0 ? S.__staleWhileFetching ? a(this, j)[t] = S.__staleWhileFetching : this.delete(e) : (n.status && (n.status.fetchUpdated = !0), this.set(e, b, c.options))), b;
  }, h = (b) => (n.status && (n.status.fetchRejected = !0, n.status.fetchError = b), m(b)), m = (b) => {
    const { aborted: k } = r.signal, p = k && n.allowStaleOnFetchAbort, w = p || n.allowStaleOnFetchRejection, S = w || n.noDeleteOnFetchRejection, C = g;
    if (a(this, j)[t] === g && (!S || C.__staleWhileFetching === void 0 ? this.delete(e) : p || (a(this, j)[t] = C.__staleWhileFetching)), w)
      return n.status && C.__staleWhileFetching !== void 0 && (n.status.returnedStale = !0), C.__staleWhileFetching;
    if (C.__returned === C)
      throw b;
  }, v = (b, k) => {
    var w;
    const p = (w = a(this, ct)) == null ? void 0 : w.call(this, e, l, c);
    p && p instanceof Promise && p.then((S) => b(S), k), r.signal.addEventListener("abort", () => {
      (!n.ignoreFetchAbort || n.allowStaleOnFetchAbort) && (b(), n.allowStaleOnFetchAbort && (b = (S) => f(S, !0)));
    });
  };
  n.status && (n.status.fetchDispatched = !0);
  const g = new Promise(v).then(f, h), $ = Object.assign(g, {
    __abortController: r,
    __staleWhileFetching: l,
    __returned: void 0
  });
  return t === void 0 ? (this.set(e, $, { ...c.options, status: void 0 }), t = a(this, re).get(e)) : a(this, j)[t] = $, $;
}, Y = new WeakSet(), ee = function(e) {
  if (!a(this, Ge))
    return !1;
  const t = e;
  return !!t && t instanceof Promise && t.hasOwnProperty("__staleWhileFetching") && t.__abortController instanceof AbortController;
}, St = new WeakSet(), nn = function(e, t) {
  a(this, ke)[t] = e, a(this, ge)[e] = t;
}, tt = new WeakSet(), kt = function(e) {
  e !== a(this, ue) && (e === a(this, me) ? R(this, me, a(this, ge)[e]) : I(this, St, nn).call(this, a(this, ke)[e], a(this, ge)[e]), I(this, St, nn).call(this, a(this, ue), e), R(this, ue, e));
};
const fs = Jt, vt = (s) => {
  const e = s.value, t = e.substring(0, s.selectionStart), n = e.substring(s.selectionEnd, e.length), i = t.lastIndexOf(`
`), l = t.substring(0, i + 1), r = n.indexOf(`
`), o = n.substring(
    r === -1 ? n.length : r,
    n.length
  ), c = t.substring(
    i + 1,
    t.length
  ), f = n.substring(0, r);
  return {
    prefixStr: t,
    subfixStr: n,
    prefixStrEndRow: l,
    subfixStrEndRow: o,
    prefixSupply: c,
    subfixSupply: f
  };
}, ms = (s, e = "", t, n) => {
  var m, v, g, $, b, k;
  let i = "", l = 0, r = 0, o = !1, c, f;
  const h = (m = te.editorConfig) == null ? void 0 : m.mermaidTemplate;
  if (/^h[1-6]{1}$/.test(s)) {
    const p = s.replace(/^h(\d)/, (w, S) => new Array(Number(S)).fill("#", 0, S).join(""));
    i = `${p} ${e}`, l = p.length + 1;
  } else if (s === "prettier") {
    const p = window.prettier || ((g = (v = te.editorExtensions) == null ? void 0 : v.prettier) == null ? void 0 : g.prettierInstance), w = [
      (($ = window.prettierPlugins) == null ? void 0 : $.markdown) || ((k = (b = te.editorExtensions) == null ? void 0 : b.prettier) == null ? void 0 : k.parserMarkdownInstance)
    ];
    return !p || w[0] === void 0 ? (x.emit(n.editorId, "errorCatcher", {
      name: "prettier",
      message: "prettier is undefined"
    }), t.value) : p.format(t.value, {
      parser: "markdown",
      plugins: w
    });
  } else
    switch (s) {
      case "bold": {
        i = `**${e}**`, l = 2, r = -2;
        break;
      }
      case "underline": {
        i = `<u>${e}</u>`, l = 3, r = -4;
        break;
      }
      case "italic": {
        i = `*${e}*`, l = 1, r = -1;
        break;
      }
      case "strikeThrough": {
        i = `~${e}~`, l = 1, r = -1;
        break;
      }
      case "sub": {
        i = `<sub>${e}</sub>`, l = 5, r = -6;
        break;
      }
      case "sup": {
        i = `<sup>${e}</sup>`, l = 5, r = -6;
        break;
      }
      case "codeRow": {
        i = "`" + e + "`", l = 1, r = -1;
        break;
      }
      case "quote": {
        i = `> ${e}`, l = 2;
        break;
      }
      case "orderedList": {
        i = `1. ${e}`, l = 3;
        break;
      }
      case "unorderedList": {
        i = `- ${e}`, l = 2;
        break;
      }
      case "task": {
        i = `- [ ] ${e}`, l = 6, o = !0;
        break;
      }
      case "code": {
        const p = n.text || e || "", w = n.mode || "language";
        i = `\`\`\`${w}
${p}
\`\`\`
`, l = 3, r = 3 + w.length - i.length, o = !0;
        break;
      }
      case "table": {
        i = "|";
        const { selectedShape: p = { x: 1, y: 1 } } = n, { x: w, y: S } = p;
        for (let C = 0; C <= S; C++)
          i += " col |";
        i += `
|`;
        for (let C = 0; C <= S; C++)
          i += " - |";
        for (let C = 0; C <= w; C++) {
          i += `
|`;
          for (let A = 0; A <= S; A++)
            i += " content |";
        }
        l = 2, r = 5 - i.length, o = !0;
        break;
      }
      case "link": {
        const { desc: p, url: w } = n;
        i = `[${p}](${w})`;
        break;
      }
      case "image": {
        const { desc: p, url: w, urls: S } = n;
        S instanceof Array ? i = S.reduce((C, A) => C + `![${p}](${A})
`, "") : i = `![${p}](${w})
`;
        break;
      }
      case "tab": {
        const { tabWidth: p = 2 } = n, w = new Array(p).fill(" ").join("");
        if (e === "")
          i = w;
        else if (/\n/.test(e)) {
          const { prefixStr: S, subfixStr: C, prefixSupply: A, subfixSupply: M } = vt(t);
          i = `${A}${e}${M}`.split(`
`).map((X) => `${w}${X}`).join(`
`), c = S.substring(0, S.length - A.length), f = C.substring(M.length, C.length), o = !0, l = p, r = -A.length - M.length;
        } else {
          const C = t.value.substring(0, t.selectionStart);
          /\n$/.test(C) || C === "" ? (i = `${w}${e}`, o = !0) : i = w;
        }
        break;
      }
      case "shiftTab": {
        const { tabWidth: p = 2 } = n, {
          prefixStr: w,
          prefixStrEndRow: S,
          subfixStrEndRow: C,
          prefixSupply: A,
          subfixSupply: M
        } = vt(t), T = new RegExp(`^\\s{${p}}`), y = (X = !1, V = !1) => {
          const q = `${A}${e}${M}`;
          if (T.test(q)) {
            const _ = w.length - (V ? 0 : p), O = X ? _ + e.length - p : _;
            return Pe(t, _, O), `${S}${q.replace(
              T,
              ""
            )}${C}`;
          } else if (/^\s/.test(q)) {
            const _ = q.replace(/^\s/, ""), O = q.length - _.length, B = t.selectionStart - (V ? 0 : O), W = X ? B + e.length - O : B;
            return Pe(t, B, W), `${S}${_}${C}`;
          } else
            i = e;
        };
        if (e === "") {
          const X = y();
          if (X)
            return X;
        } else if (/\n/.test(e)) {
          const V = `${A}${e}${M}`.split(`
`);
          let [q, _] = [0, 0];
          const O = V.map((B, W) => {
            if (T.test(B))
              return W === 0 && (q = p), _ += p, B.replace(T, "");
            if (/^\s/.test(B)) {
              const H = B.replace(/^\s/, "");
              return _ += B.length - H.length, H;
            }
            return B;
          }).join(`
`);
          return Pe(
            t,
            t.selectionStart - q,
            t.selectionEnd - _
          ), `${S}${O}${C}`;
        } else {
          const X = y(!0, !0);
          if (X)
            return X;
        }
        break;
      }
      case "ctrlC": {
        const { prefixSupply: p, subfixSupply: w } = vt(t);
        return bt(e === "" ? `${p}${w}` : e), t.value;
      }
      case "ctrlX": {
        const {
          prefixStrEndRow: p,
          subfixStrEndRow: w,
          prefixStr: S,
          subfixStr: C,
          prefixSupply: A,
          subfixSupply: M
        } = vt(t);
        return e === "" ? (bt(`${A}${M}`), Pe(t, p.length), `${p}${w.replace(/^\n/, "")}`) : (bt(e), Pe(t, S.length), `${S}${C}`);
      }
      case "ctrlD": {
        const { prefixStrEndRow: p, subfixStrEndRow: w } = vt(t);
        return Pe(t, p.length), `${p}${w.replace(/^\n/, "")}`;
      }
      case "flow": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.flow) || `flowchart TD 
  Start --> Stop`}
\`\`\`
`, l = 2;
        break;
      }
      case "sequence": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.sequence) || `sequenceDiagram
  A->>B: hello!
  B-->>A: hi!
  A-)B: bye!`}
\`\`\`
`, l = 2;
        break;
      }
      case "gantt": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.gantt) || `gantt
title A Gantt Diagram
dateFormat  YYYY-MM-DD
section Section
A task  :a1, 2014-01-01, 30d
Another task  :after a1, 20d`}
\`\`\`
`, l = 2;
        break;
      }
      case "class": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.class) || `classDiagram
  class Animal
  Vehicle <|-- Car`}
\`\`\`
`, l = 2;
        break;
      }
      case "state": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.state) || `stateDiagram-v2
  s1 --> s2`}
\`\`\`
`, l = 2;
        break;
      }
      case "pie": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.pie) || `pie title Pets adopted by volunteers
  "Dogs" : 386
  "Cats" : 85
  "Rats" : 15`}
\`\`\`
`, l = 2;
        break;
      }
      case "relationship": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.relationship) || `erDiagram
  CAR ||--o{ NAMED-DRIVER : allows
  PERSON ||--o{ NAMED-DRIVER : is`}
\`\`\`
`, l = 2;
        break;
      }
      case "journey": {
        i = `\`\`\`mermaid
${(h == null ? void 0 : h.journey) || `journey
  title My working day
  section Go to work
    Make tea: 5: Me
    Go upstairs: 3: Me
    Do work: 1: Me, Cat
  section Go home
    Go downstairs: 5: Me
    Sit down: 5: Me`}
\`\`\`
`, l = 2;
        break;
      }
      case "katexInline": {
        i = "$$", l = 1, r = -1;
        break;
      }
      case "katexBlock": {
        i = `$$

$$
`, l = 1, r = -4;
        break;
      }
      case "universal": {
        const { generate: p } = n, w = p(e);
        i = w.targetValue, o = w.select, l = w.deviationStart, r = w.deviationEnd;
      }
    }
  return Qt(t, i, {
    deviationStart: l,
    deviationEnd: r,
    select: o,
    prefixVal: c,
    subfixVal: f
  });
}, On = {
  block(s, e) {
    return {
      name: "KaTexBlockExtension",
      level: "block",
      start: (t) => {
        var n;
        return (n = t.match(/\n\$\$/)) == null ? void 0 : n.index;
      },
      tokenizer(t) {
        if (/^\$\$/.test(t) && t.split("$$").length > 2) {
          const n = yn(t, "$$");
          return {
            type: "KaTexBlockExtension",
            raw: n[0],
            text: n[1].trim(),
            tokens: []
          };
        }
      },
      renderer(t) {
        const n = e || typeof window < "u" && window.katex;
        if (n) {
          const i = n.renderToString(t.text, {
            throwOnError: !1,
            displayMode: !0
          });
          return `<p class="${s}-katex-block" data-processed>${i}</p>`;
        } else
          return `<p class="${s}-katex-block">${t.text}</p>`;
      }
    };
  },
  inline(s, e) {
    return {
      name: "KaTexInlineExtension",
      level: "inline",
      start: (t) => {
        var n;
        return (n = t.match(/\$[^\n]*/)) == null ? void 0 : n.index;
      },
      tokenizer(t) {
        if (/^\$[^\n]*\$/.test(t)) {
          const n = yn(t);
          return {
            type: "KaTexInlineExtension",
            raw: n[0],
            text: n[1].trim(),
            tokens: []
          };
        }
      },
      renderer(t) {
        const n = e || typeof window < "u" && window.katex;
        if (n) {
          const i = n.renderToString(t.text, {
            throwOnError: !1
          });
          return `<span class="${s}-katex-inline" data-processed>${i}</span>`;
        } else
          return `<span class="${s}-katex-inline">${t.text}</span>`;
      }
    };
  }
}, Xn = [
  "abstract",
  "attention",
  "bug",
  "caution",
  "danger",
  "error",
  "example",
  "failure",
  "hint",
  "info",
  "note",
  "question",
  "quote",
  "success",
  "tip",
  "warning"
], Xt = new RegExp(`^!!!\\s*(${Xn.join("|")})\\s*(.*)$`), gs = /^!!!\s*$/, ps = {
  name: "alert",
  level: "block",
  start(s) {
    var t;
    return (t = s.match(
      new RegExp(`(^|[\\r\\n])!!!\\s*(${Xn.join("|")})\\s*(.*)`)
    )) == null ? void 0 : t.index;
  },
  tokenizer(s) {
    const e = s.split(/\n/);
    if (Xt.test(e[0])) {
      const t = { x: -1, y: -1 }, n = [];
      for (let i = 0, l = e.length; i < l; i++)
        Xt.test(e[i]) ? t.x = i : gs.test(e[i]) && (t.y = i, t.x >= 0 && (n.push({ ...t }), t.x = -1, t.y = -1));
      if (n.length) {
        const i = n[0], [l, r, o] = Xt.exec(e[i.x]) || [], c = e.slice(i.x + 1, i.y).join(`
`), h = {
          type: "alert",
          raw: e.slice(i.x, i.y + 1).join(`
`),
          icon: r,
          title: o,
          text: c,
          titleTokens: [],
          tokens: [],
          childTokens: ["title", "text"]
        };
        return this.lexer.inlineTokens(h.title, h.titleTokens), this.lexer.blockTokens(h.text, h.tokens), h;
      }
    }
  },
  renderer(s) {
    return `<div class="md-editor-alert md-editor-alert-${s.icon}">
     <p class="md-editor-alert-title">${this.parser.parseInline(
      s.titleTokens,
      null
    )}</p>
     ${this.parser.parse(s.tokens)}
     </div>`;
  }
}, vs = typeof window > "u", bs = (s, e, t) => {
  var g, $;
  const n = U("previewOnly"), i = U("historyLength"), l = U("editorId");
  if (n)
    return;
  let r = -1;
  const o = {
    list: [
      {
        content: s.value,
        startPos: ((g = e.value) == null ? void 0 : g.selectionStart) || 0,
        endPos: (($ = e.value) == null ? void 0 : $.selectionEnd) || 0
      }
    ],
    userUpdated: !0,
    curr: 0
  }, c = [0, 0];
  let f = c;
  const h = (b) => {
    var S, C;
    const k = ((S = e.value) == null ? void 0 : S.selectionStart) || 0, p = ((C = e.value) == null ? void 0 : C.selectionEnd) || 0;
    o.list[o.curr].startPos = k, o.list[o.curr].endPos = p, o.userUpdated = !1, o.curr = b;
    const w = o.list[o.curr];
    f = [w.startPos, w.endPos], s.onChange(w.content), Pe(e.value, w.startPos, w.endPos).then(() => {
      x.emit(l, "selectTextChange");
    });
  }, m = (b) => {
    var w, S;
    clearTimeout(r);
    const k = ((w = e.value) == null ? void 0 : w.selectionStart) || 0, p = ((S = e.value) == null ? void 0 : S.selectionEnd) || 0;
    r = setTimeout(() => {
      if (o.userUpdated) {
        o.curr < o.list.length - 1 && (o.list = o.list.slice(0, o.curr + 1)), o.list.length > i && o.list.shift();
        const C = o.list.pop() || {
          startPos: 0,
          endPos: 0,
          content: b
        };
        C.startPos = f[0], C.endPos = f[1], f = c, Array.prototype.push.call(o.list, C, {
          content: b,
          startPos: k,
          endPos: p
        }), o.curr = o.list.length - 1;
      } else
        o.userUpdated = !0;
    }, 150);
  }, v = (b) => {
    var k, p;
    (f === c || b) && (f = [(k = e.value) == null ? void 0 : k.selectionStart, (p = e.value) == null ? void 0 : p.selectionEnd]);
  };
  G([Bt(s, "value"), t], () => {
    t.value && m(s.value);
  }), G(
    () => s.value,
    () => {
      x.emit(l, "selectTextChange");
    },
    {
      flush: "post"
    }
  ), ie(() => {
    x.on(l, {
      name: "ctrlZ",
      callback() {
        h(o.curr - 1 < 0 ? 0 : o.curr - 1);
      }
    }), x.on(l, {
      name: "ctrlShiftZ",
      callback() {
        h(
          o.curr + 1 === o.list.length ? o.curr : o.curr + 1
        );
      }
    }), x.on(l, {
      name: "saveHistoryPos",
      callback: v
    });
  });
}, ks = (s, e) => {
  var l;
  const t = (l = te.editorExtensions) == null ? void 0 : l.katex, n = t == null ? void 0 : t.instance, i = ne(!1);
  return s.noKatex || e.use({
    extensions: [
      On.inline(d, n),
      On.block(d, n)
    ]
  }), ie(() => {
    if (!s.noKatex && !n) {
      const r = document.createElement("script");
      r.src = (t == null ? void 0 : t.js) || Nt.js, r.onload = () => {
        i.value = !0;
      }, r.id = `${d}-katex`;
      const o = document.createElement("link");
      o.rel = "stylesheet", o.href = (t == null ? void 0 : t.css) || Nt.css, o.id = `${d}-katexCss`, we(r, "katex"), we(o);
    }
  }), i;
}, ys = (s) => {
  var W, H, se;
  const {
    markedRenderer: e,
    markedExtensions: t,
    markedOptions: n,
    editorExtensions: i,
    editorConfig: l
  } = te, r = U("showCodeRowNumber"), o = U("editorId"), c = U("highlight"), f = U("previewOnly"), h = U("theme"), m = (W = i == null ? void 0 : i.highlight) == null ? void 0 : W.instance, v = (H = i == null ? void 0 : i.mermaid) == null ? void 0 : H.instance, g = (se = i == null ? void 0 : i.katex) == null ? void 0 : se.instance, $ = i == null ? void 0 : i.katex, b = ne(!1), k = ne([]);
  let p = [], w = [];
  const S = new fs({
    max: 1e3,
    // 缓存10分钟
    ttl: 6e5
  }), C = $s(s), A = ks(s, z), M = ze(() => (s.noMermaid || C.mermaidInited) && b.value && (s.noKatex || A.value));
  let T = new z.Renderer();
  T.image = (F, D, N) => `<span class="figure"><img src="${F}" title="${D || ""}" alt="${N || ""}" zoom><span class="figcaption">${N || ""}</span></span>`, T.listitem = (F, D) => D ? `<li class="li-task">${F}</li>` : `<li>${F}</li>`, e instanceof Function && (T = e(T));
  const y = T.code;
  T.code = (F, D, N) => {
    if (!s.noMermaid && D === "mermaid") {
      const ce = pi();
      try {
        if (vs)
          return `<p class="${d}-mermaid">${F}</p>`;
        {
          const ve = S.get(F);
          if (ve)
            return `<p class="${d}-mermaid" data-processed>${ve}</p>`;
          const Ie = v || window.mermaid;
          if (C.mermaidInited) {
            const Xe = (Ie.renderAsync || Ie.render)(ce, F);
            Xe.then((qe) => {
              S.set(F, typeof qe == "string" ? qe : qe.svg);
            }), p.push(Xe);
          } else
            return `<p class="${d}-mermaid">${F}</p>`;
        }
        const de = `<script type="text/tmplate">${ce}<\/script>`;
        return w.push(de), de;
      } catch (de) {
        return `<p class="${d}-mermaid-error">Error: ${(de == null ? void 0 : de.message) || ""}</p>`;
      }
    }
    return y.call(T, F, D, N).replace(
      /^<pre><code\sclass="language-([^>]*)">/,
      '<pre><code class="language-$1" language="$1">'
    );
  };
  const X = T.heading, V = X !== new z.Renderer().heading;
  T.heading = (F, D, N, ce) => {
    k.value.push({ text: N, level: D });
    const de = s.markedHeadingId(N, D, k.value.length);
    return V ? X.call(
      T,
      F,
      D,
      N,
      ce,
      k.value.length,
      de
    ) : F !== N ? `<h${D} id="${de}">${F}</h${D}>` : `<h${D} id="${de}"><a href="#${de}">${N}</a></h${D}>`;
  }, m && z.setOptions({
    highlight: (F, D) => {
      let N;
      const ce = m.getLanguage(D);
      return D && ce ? N = m.highlight(F, {
        language: D,
        ignoreIllegals: !0
      }).value : N = m.highlightAuto(F).value, r ? kn(N) : `<span class="code-block">${N}</span>`;
    }
  }), z.setOptions({
    breaks: !0,
    ...n
  }), t instanceof Array && t.length > 0 && z.use({
    extensions: t
  }), z.use({
    extensions: [ps]
  });
  const q = ne(s.sanitize(z(s.value || "", { renderer: T }))), _ = async (F) => {
    let D = s.sanitize(z(F, { renderer: T }));
    const N = [...p], ce = [...w];
    return w = [], p = [], (await Promise.allSettled(N)).forEach((ve, Ie) => {
      ve.status === "fulfilled" ? D = D.replace(
        ce[Ie],
        `<p class="${d}-mermaid" data-processed>${typeof ve.value == "string" ? ve.value : ve.value.svg}</p>`
      ) : D = D.replace(
        ce[Ie],
        `<p class="${d}-mermaid-error">${ve.reason || ""}</p>`
      );
    }), D;
  }, O = Gt(
    async () => {
      k.value = [];
      const F = await _(s.value || "");
      q.value = F, x.emit(o, "buildFinished", q.value), s.onHtmlChanged(q.value);
    },
    (l == null ? void 0 : l.renderDelay) !== void 0 ? l == null ? void 0 : l.renderDelay : f ? 0 : 500
  );
  G(
    [M, Bt(C, "reRender"), Bt(s, "value")],
    O
  ), G([h], () => {
    S.clear();
  });
  const B = () => {
    z.setOptions({
      highlight: (F, D) => {
        let N;
        const ce = window.hljs.getLanguage(D);
        return D && ce ? N = window.hljs.highlight(F, {
          language: D,
          ignoreIllegals: !0
        }).value : N = window.hljs.highlightAuto(F).value, r ? kn(N) : `<span class="code-block">${N}</span>`;
      }
    }), b.value = !0;
  };
  return G(
    () => k.value,
    (F) => {
      s.onGetCatalog(F), x.emit(o, "catalogChanged", F);
    }
  ), ie(() => {
    if (!s.noKatex && !g) {
      const D = document.createElement("script");
      D.src = ($ == null ? void 0 : $.js) || Nt.js, D.onload = () => {
        A.value = !0;
      }, D.id = `${d}-katex`;
      const N = document.createElement("link");
      N.rel = "stylesheet", N.href = ($ == null ? void 0 : $.css) || Nt.css, N.id = `${d}-katexCss`, we(D, "katex"), we(N);
    }
    const F = document.createElement("link");
    if (F.rel = "stylesheet", F.href = c.value.css, F.id = `${d}-hlCss`, we(F), !m) {
      const D = document.createElement("script");
      D.src = c.value.js, D.onload = B, D.id = `${d}-hljs`, we(D, "hljs");
    }
  }), G(
    () => c.value.css,
    (F) => {
      vi(`${d}-hlCss`, "href", F);
    }
  ), ie(() => {
    x.on(o, {
      name: "pushCatalog",
      callback() {
        x.emit(o, "catalogChanged", k.value);
      }
    });
  }), q;
}, ws = (s, e, t, n, i) => {
  const l = U("previewOnly"), r = U("usedLanguageText"), o = U("editorId");
  let c = () => {
  }, f = () => {
  };
  const h = () => {
    document.querySelectorAll(`#${o}-preview pre`).forEach((g) => {
      var p, w;
      let $ = -1;
      (p = g.querySelector(".copy-button")) == null || p.remove();
      const b = ((w = r.value.copyCode) == null ? void 0 : w.text) || "复制代码", k = document.createElement("span");
      k.setAttribute("class", "copy-button"), k.dataset.tips = b, k.innerHTML = `<svg class="${d}-icon" aria-hidden="true"><use xlink:href="#${d}-icon-copy"></use></svg>`, k.addEventListener("click", () => {
        var T, y;
        clearTimeout($);
        const S = g.querySelector("code").innerText, C = bt(s.formatCopiedText(S)), A = ((T = r.value.copyCode) == null ? void 0 : T.successTips) || "已复制！", M = ((y = r.value.copyCode) == null ? void 0 : y.failTips) || "已复制！";
        k.dataset.tips = C ? A : M, $ = window.setTimeout(() => {
          k.dataset.tips = b;
        }, 1500);
      }), g.appendChild(k);
    });
  }, m = () => {
    ft(() => {
      s.setting.preview && !l && s.scrollAuto && (c(), f()), h();
    });
  }, v = (g) => {
    g && !l && ft(() => {
      c(), [f, c] = bn(
        t.value,
        n.value || i.value
      ), f(), h();
    });
  };
  G(() => e.value, m), G(() => r.value, h), G(() => s.setting.preview, v), G(() => s.setting.htmlPreview, v), G(
    () => s.scrollAuto,
    (g) => {
      g ? f() : c();
    }
  ), ie(() => {
    h(), !l && (n.value || i.value) && ([f, c] = bn(
      t.value,
      n.value || i.value
    )), s.scrollAuto && f();
  });
}, xs = (s, e) => {
  const t = U("previewOnly"), n = U("tabWidth"), i = U("editorId"), l = ne("");
  ie(() => {
    var r;
    t || ((r = e.value) == null || r.addEventListener("keypress", (o) => {
      var c, f, h;
      if (o.key === "Enter") {
        const m = (c = e.value) == null ? void 0 : c.selectionStart, v = (f = e.value) == null ? void 0 : f.value.substring(0, m), g = (h = e.value) == null ? void 0 : h.value.substring(m), $ = v == null ? void 0 : v.lastIndexOf(`
`), b = v == null ? void 0 : v.substring(
          $ + 1,
          m
        );
        if (/^\d+\.\s|^-\s/.test(b))
          if (o.cancelBubble = !0, o.preventDefault(), o.stopPropagation(), /^(\d+\.|-)\s+(\[[x\s]\]\s+)?$/.test(b)) {
            const k = v == null ? void 0 : v.replace(
              /(\d+\.|-)\s+(\[[x\s]\]\s+)?$/,
              ""
            );
            s.onChange(k + g), Pe(
              e.value,
              k == null ? void 0 : k.length
            );
          } else if (/^-\s+.+/.test(b)) {
            const k = /^-\s+\[[x\s]\]/.test(b) ? `
- [ ] ` : `
- `;
            s.onChange(
              Qt(e.value, k, {})
            );
          } else {
            const k = b == null ? void 0 : b.match(/\d+(?=\.)/), p = k && Number(k[0]) + 1 || 1, w = /^\d\.\s+\[[x\s]\]/.test(b) ? `
${p}. [ ] ` : `
${p}. `;
            s.onChange(
              Qt(e.value, w, {})
            );
          }
      }
    }), x.on(i, {
      name: "replace",
      callback(o, c = {}) {
        s.onChange(
          ms(
            o,
            l.value,
            e.value,
            {
              ...c,
              tabWidth: n,
              editorId: i
            }
          )
        );
      }
    }), x.on(i, {
      name: "selectTextChange",
      callback() {
        l.value = fi(e.value);
      }
    }));
  }), G(
    () => s.value,
    () => {
      l.value = "";
    }
  );
}, $s = (s) => {
  const e = U("theme"), { editorExtensions: t } = te, n = t == null ? void 0 : t.mermaid, i = xe({
    reRender: !1,
    mermaidInited: !1
  }), l = () => {
    const r = (n == null ? void 0 : n.instance) || window.mermaid;
    !s.noMermaid && r && (r.initialize({
      startOnLoad: !1,
      theme: e.value === "dark" ? "dark" : "default"
    }), i.reRender = !i.reRender);
  };
  return G(() => e.value, l), ie(() => {
    if (!s.noMermaid)
      if (n != null && n.instance)
        l(), i.mermaidInited = !0;
      else {
        const r = document.createElement("script");
        r.id = `${d}-mermaid`;
        const o = (n == null ? void 0 : n.js) || ri;
        /\.mjs/.test(o) ? (r.setAttribute("type", "module"), r.innerHTML = `import mermaid from "${o}";window.mermaid=mermaid;document.getElementById('${d}-mermaid').dispatchEvent(new Event('load'));`) : r.src = o, r.onload = () => {
          l(), i.mermaidInited = !0;
        }, we(r, "mermaid");
      }
  }), i;
}, Ss = (s, e) => {
  const t = U("editorId"), n = U("previewOnly"), i = (l) => {
    if (l.clipboardData) {
      if (l.clipboardData.files.length > 0) {
        const { files: r } = l.clipboardData;
        x.emit(
          t,
          "uploadImage",
          Array.from(r).filter((o) => /image\/.*/.test(o.type))
        ), l.preventDefault();
      }
      if (s.autoDetectCode && l.clipboardData.types.includes("vscode-editor-data")) {
        const r = JSON.parse(l.clipboardData.getData("vscode-editor-data"));
        x.emit(t, "replace", "code", {
          mode: r.mode,
          text: l.clipboardData.getData("text/plain")
        }), l.preventDefault();
      }
    }
  };
  ie(() => {
    n || e.value.addEventListener("paste", i);
  }), Ct(() => {
    n || e.value.removeEventListener("paste", i);
  });
}, Cs = (s, e) => {
  const t = U("editorId"), n = Gt(() => {
    const i = document.querySelectorAll(`#${t}-preview img[zoom]`);
    i.length !== 0 && us(i, {
      background: "#00000073"
    });
  });
  ie(n), G([e, Bt(s.setting, "preview")], n);
}, Ts = (s) => {
  const e = U("editorId");
  ie(() => {
    x.on(e, {
      name: Pn,
      callback() {
        var t;
        (t = s.value) == null || t.focus();
      }
    });
  });
}, Es = () => ({
  value: {
    type: String,
    default: ""
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  markedHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: !1
  },
  sanitize: {
    type: Function,
    default: (s) => s
  },
  placeholder: {
    type: String,
    default: ""
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: !1
  },
  scrollAuto: {
    type: Boolean
  },
  formatCopiedText: {
    type: Function,
    default: (s) => s
  },
  autofocus: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {
    }
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {
    }
  }
}), zs = /* @__PURE__ */ ae({
  name: "MDEditorContent",
  props: Es(),
  setup(s) {
    const e = ne(!0), t = U("previewOnly"), n = U("showCodeRowNumber"), i = U("previewTheme"), l = U("editorId"), r = ne(), o = ne(), c = ne(), f = ys(s);
    return ws(s, f, r, o, c), xs(s, r), bs(s, r, e), Ss(s, r), Cs(s, f), Ts(r), () => {
      const h = gi(s, ["formatCopiedText", "markedHeadingId", "noKatex", "noMermaid", "onChange", "onGetCatalog", "onHtmlChanged", "sanitize", "scrollAuto", "setting", "autoDetectCode", "onBlur", "onFocus"]);
      return u(Kt, null, [u("div", {
        class: `${d}-content`
      }, [!t && u("div", {
        class: `${d}-input-wrapper`
      }, [u("textarea", ti(h, {
        id: `${l}-textarea`,
        class: [s.setting.preview || s.setting.htmlPreview ? "" : "textarea-only"],
        ref: r,
        onBlur: (m) => {
          x.emit(l, "selectTextChange"), s.onBlur(m);
        },
        onFocus: s.onFocus,
        onKeydown: () => {
          x.emit(l, "saveHistoryPos", !0);
        },
        onCompositionstart: () => {
          e.value = !1;
        },
        onInput: (m) => {
          s.onChange(m.target.value);
        },
        onCompositionend: () => {
          e.value = !0;
        }
      }), null)]), s.setting.preview && u("div", {
        id: `${l}-preview-wrapper`,
        class: `${d}-preview-wrapper`,
        ref: o,
        key: "content-preview-wrapper"
      }, [u("article", {
        id: `${l}-preview`,
        class: [`${d}-preview`, `${i == null ? void 0 : i.value}-theme`, n && `${d}-scrn`],
        innerHTML: f.value
      }, null)]), s.setting.htmlPreview && u("div", {
        class: `${d}-preview-wrapper`,
        ref: c,
        key: "html-preview-wrapper"
      }, [u("div", {
        class: `${d}-html`
      }, [f.value])])])]);
    };
  }
}), _s = /* @__PURE__ */ ae({
  props: {
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(s) {
    const e = U("usedLanguageText");
    return () => {
      var t, n;
      return u("div", {
        class: `${d}-footer-item`
      }, [u("label", {
        class: `${d}-footer-label`
      }, [`${(t = e.value.footer) == null ? void 0 : t.markdownTotal}:`]), u("span", null, [((n = s.modelValue) == null ? void 0 : n.length) || 0])]);
    };
  }
});
const As = () => ({
  checked: {
    type: Boolean,
    default: !1
  },
  onChange: {
    type: Function,
    default: () => {
    }
  }
}), Is = /* @__PURE__ */ ae({
  props: As(),
  setup(s) {
    return () => u("div", {
      class: [`${d}-checkbox`, s.checked && `${d}-checkbox-checked`],
      onClick: () => {
        s.onChange(!s.checked);
      }
    }, null);
  }
}), Ls = () => ({
  scrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {
    }
  }
}), Fs = /* @__PURE__ */ ae({
  props: Ls(),
  setup(s) {
    const e = U("usedLanguageText");
    return () => {
      var t;
      return u("div", {
        class: `${d}-footer-item`
      }, [u("label", {
        class: `${d}-footer-label`,
        onClick: () => {
          s.onScrollAutoChange(!s.scrollAuto);
        }
      }, [(t = e.value.footer) == null ? void 0 : t.scrollAuto]), u(Is, {
        checked: s.scrollAuto,
        onChange: s.onScrollAutoChange
      }, null)]);
    };
  }
}), Rs = () => ({
  modelValue: {
    type: String,
    default: ""
  },
  footers: {
    type: Array,
    default: []
  },
  scrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {
    }
  },
  defFooters: {
    type: Object
  }
}), Os = /* @__PURE__ */ ae({
  name: "MDEditorFooter",
  props: Rs(),
  setup(s) {
    const e = ze(() => {
      const n = s.footers.indexOf("="), i = n === -1 ? s.footers : s.footers.slice(0, n), l = n === -1 ? [] : s.footers.slice(n, Number.MAX_SAFE_INTEGER);
      return [i, l];
    }), t = (n) => {
      if (Hn.includes(n))
        switch (n) {
          case "markdownTotal":
            return u(_s, {
              modelValue: s.modelValue
            }, null);
          case "scrollSwitch":
            return u(Fs, {
              scrollAuto: s.scrollAuto,
              onScrollAutoChange: s.onScrollAutoChange
            }, null);
        }
      else
        return s.defFooters instanceof Array ? s.defFooters[n] || "" : s.defFooters && s.defFooters.children instanceof Array && s.defFooters.children[n] || "";
    };
    return () => {
      const n = e.value[0].map((l) => t(l)), i = e.value[1].map((l) => t(l));
      return u("div", {
        class: `${d}-footer`
      }, [u("div", {
        class: `${d}-footer-left`
      }, [n]), u("div", {
        class: `${d}-footer-right`
      }, [i])]);
    };
  }
}), Ds = () => ({
  tocItem: {
    type: Object,
    default: () => ({})
  },
  markedHeadingId: {
    type: Function,
    default: () => {
    }
  },
  scrollElement: {
    type: [String, Object],
    default: ""
  },
  onClick: {
    type: Function,
    default: () => {
    }
  },
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  }
}), Qn = /* @__PURE__ */ ae({
  props: Ds(),
  setup(s) {
    return () => {
      const {
        tocItem: e,
        markedHeadingId: t,
        scrollElement: n,
        onClick: i,
        scrollElementOffsetTop: l
      } = s;
      return u("div", {
        class: [`${d}-catalog-link`, e.active && `${d}-catalog-active`],
        onClick: (r) => {
          i(r, e), r.stopPropagation();
          const o = t(e.text, e.level, e.index), c = document.getElementById(o), f = n instanceof Element ? n : document.querySelector(n);
          if (c && f) {
            let h = c.offsetParent, m = c.offsetTop;
            if (f.contains(h))
              for (; h && f != h; )
                m += h == null ? void 0 : h.offsetTop, h = h == null ? void 0 : h.offsetParent;
            f == null || f.scrollTo({
              top: m - l,
              behavior: "smooth"
            });
          }
        }
      }, [u("span", {
        title: e.text
      }, [e.text]), u("div", {
        class: `${d}-catalog-wrapper`
      }, [e.children && e.children.map((r) => u(Qn, {
        markedHeadingId: t,
        key: `${e.text}-link-${r.level}-${r.text}`,
        tocItem: r,
        scrollElement: n,
        onClick: i,
        scrollElementOffsetTop: l
      }, null))])]);
    };
  }
});
const Hs = () => ({
  /**
   * 编辑器的Id，务必与需要绑定的编辑器Id相同
   */
  editorId: {
    type: String
  },
  class: {
    type: String,
    default: ""
  },
  markedHeadingId: {
    type: Function,
    default: (s) => s
  },
  /**
   * 指定滚动的容器，选择器需带上对应的符号，默认预览框
   * 元素必须定位！！！！！！
   *
   * 默认：#md-editor-preview-wrapper
   */
  scrollElement: {
    type: [String, Object]
  },
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 高亮标题相对滚动容器顶部偏移量，即距离该值时，高亮当前目录菜单项
   *
   * 默认：20px
   */
  offsetTop: {
    type: Number,
    default: 20
  },
  /**
   * 滚动区域的固定顶部高度
   *
   * 默认：0
   */
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function
  }
}), Vt = /* @__PURE__ */ ae({
  name: "MdCatalog",
  props: Hs(),
  emits: ["onClick"],
  setup(s, e) {
    const t = s.editorId, n = xe({
      list: [],
      show: !1,
      scrollElement: s.scrollElement || `#${t}-preview-wrapper`
    }), i = ze(() => {
      const r = [];
      return n.list.forEach(({
        text: o,
        level: c,
        active: f
      }, h) => {
        const m = {
          level: c,
          text: o,
          index: h + 1,
          active: !!f
        };
        if (r.length === 0)
          r.push(m);
        else {
          let v = r[r.length - 1];
          if (m.level > v.level)
            for (let g = v.level + 1; g <= 6; g++) {
              const {
                children: $
              } = v;
              if (!$) {
                v.children = [m];
                break;
              }
              if (v = $[$.length - 1], m.level <= v.level) {
                $.push(m);
                break;
              }
            }
          else
            r.push(m);
        }
      }), r;
    });
    ie(() => {
      x.on(t, {
        name: "catalogChanged",
        callback: (r) => {
          n.list = r.map((o, c) => c === 0 ? {
            ...o,
            active: !0
          } : {
            ...o
          });
        }
      }), x.emit(t, "pushCatalog");
    });
    const l = () => {
      var o;
      const r = n.scrollElement instanceof HTMLElement ? n.scrollElement : document.querySelector(n.scrollElement);
      (o = r === document.documentElement ? window : r) == null || o.addEventListener("scroll", hi(() => {
        if (n.list.length === 0)
          return !1;
        const {
          activeHead: c
        } = n.list.reduce((f, h, m) => {
          const v = document.getElementById(s.markedHeadingId(h.text, h.level, m + 1));
          if (v instanceof HTMLElement) {
            const g = mi(v, r);
            if (g < s.offsetTop && g > f.minTop)
              return {
                activeHead: h,
                minTop: g
              };
          }
          return f;
        }, {
          activeHead: n.list[0],
          minTop: Number.MIN_SAFE_INTEGER
        });
        n.list = n.list.map((f) => f === c ? {
          ...f,
          active: !0
        } : {
          ...f,
          active: !1
        });
      }));
    };
    return ie(() => {
      l(), x.on(t, {
        name: Yt,
        callback(r) {
          r && ft(l);
        }
      });
    }), () => u("div", {
      class: `${d}-catalog${s.theme === "dark" ? "-dark" : ""} ${s.class}`
    }, [i.value.map((r) => u(Qn, {
      markedHeadingId: s.markedHeadingId,
      tocItem: r,
      key: `link-${r.level}-${r.text}`,
      scrollElement: n.scrollElement,
      onClick: (o, c) => {
        s.onClick ? s.onClick(o, c) : e.emit("onClick", o, c);
      },
      scrollElementOffsetTop: s.scrollElementOffsetTop
    }, null))]);
  }
}), js = (s) => s, Ps = {
  /**
   * 主题
   *
   * @default 'light'
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 历史记录最长条数
   *
   * @default 10
   */
  historyLength: {
    type: Number,
    default: 10
  },
  /**
   * input回调事件
   */
  onChange: {
    type: Function
  },
  /**
   * input回调事件
   */
  onSave: {
    type: Function
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: !1
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: !0
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: !1
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @default false
   */
  previewOnly: {
    type: Boolean,
    default: !1
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: Dn
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: !1
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: ii
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default false
   */
  showCodeRowNumber: {
    type: Boolean,
    default: !1
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  markedHeadingId: {
    type: Function,
    default: js
  },
  /**
   * 表格预设格子数
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: !1
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (s) => s
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ""
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: !1
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object]
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: Hn
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: !0
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object]
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (s) => s
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: !0
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function
  }
}, Ms = [
  "onChange",
  "onSave",
  "onUploadImg",
  "onHtmlChanged",
  "onGetCatalog",
  "onError",
  "update:modelValue",
  "onBlur",
  "onFocus"
];
const Ze = /* @__PURE__ */ ae({
  name: "MdEditorV3",
  props: Ps,
  emits: Ms,
  setup(s, e) {
    const {
      editorId: t,
      previewOnly: n,
      noKatex: i,
      noMermaid: l,
      noPrettier: r,
      noUploadImg: o
    } = s, c = xe({
      scrollAuto: s.scrollAuto
    });
    bi(s, e), ki(s), yi(s);
    const [f, h] = wi(s, e), [m, v] = xi(s);
    return Ct(() => {
      x.clear(t);
    }), $i(s, e, m, f, h), () => {
      var b;
      const g = _e({
        props: s,
        ctx: e
      }, "defToolbars"), $ = _e({
        props: s,
        ctx: e
      }, "defFooters");
      return u("div", {
        id: t,
        class: [d, s.class, s.theme === "dark" && `${d}-dark`, f.fullscreen || f.pageFullscreen ? `${d}-fullscreen` : "", n && `${d}-previewOnly`],
        style: s.style
      }, [!n && u(Hi, {
        noPrettier: r,
        toolbars: s.toolbars,
        toolbarsExclude: s.toolbarsExclude,
        setting: f,
        updateSetting: h,
        tableShape: s.tableShape,
        defToolbars: g,
        noUploadImg: o
      }, null), u(zs, {
        value: s.modelValue,
        setting: f,
        markedHeadingId: s.markedHeadingId,
        noMermaid: l,
        sanitize: s.sanitize,
        placeholder: s.placeholder,
        noKatex: i,
        scrollAuto: c.scrollAuto,
        formatCopiedText: s.formatCopiedText,
        autofocus: s.autoFocus,
        disabled: s.disabled,
        readonly: s.readOnly,
        maxlength: s.maxLength,
        autoDetectCode: s.autoDetectCode,
        onChange: (k) => {
          x.emit(t, "saveHistoryPos"), s.onChange ? s.onChange(k) : (e.emit("update:modelValue", k), e.emit("onChange", k));
        },
        onHtmlChanged: (k) => {
          s.onHtmlChanged ? s.onHtmlChanged(k) : e.emit("onHtmlChanged", k);
        },
        onGetCatalog: (k) => {
          s.onGetCatalog ? s.onGetCatalog(k) : e.emit("onGetCatalog", k);
        },
        onBlur: (k) => {
          s.onBlur ? s.onBlur(k) : e.emit("onBlur", k);
        },
        onFocus: (k) => {
          s.onFocus ? s.onFocus(k) : e.emit("onFocus", k);
        }
      }, null), !n && ((b = s.footers) == null ? void 0 : b.length) > 0 && u(Os, {
        modelValue: s.modelValue,
        footers: s.footers,
        defFooters: $,
        scrollAuto: c.scrollAuto,
        onScrollAutoChange: (k) => c.scrollAuto = k
      }, null), v.value && !n && u(Vt, {
        theme: s.theme,
        style: {
          display: m.value ? "block" : "none"
        },
        class: `${d}-catalog-editor`,
        editorId: t,
        markedHeadingId: s.markedHeadingId
      }, null)]);
    };
  }
}), Bs = () => ({
  title: {
    type: String,
    default: ""
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object]
  },
  onClick: {
    type: Function
  }
}), sn = /* @__PURE__ */ ae({
  name: "NormalToolbar",
  props: Bs(),
  emits: ["onClick"],
  setup(s, e) {
    return () => {
      const t = _e({
        props: s,
        ctx: e
      }, "trigger");
      return u("div", {
        class: `${d}-toolbar-item`,
        title: s.title,
        onClick: (n) => {
          s.onClick instanceof Function ? s.onClick(n) : e.emit("onClick", n);
        }
      }, [t]);
    };
  }
}), Ns = () => ({
  title: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object]
  },
  onChange: {
    type: Function
  },
  // 下拉框中的内容
  overlay: {
    type: [String, Object]
  }
}), ln = /* @__PURE__ */ ae({
  name: "DropdownToolbar",
  props: Ns(),
  emits: ["onChange"],
  setup(s, e) {
    const t = U("editorId");
    return () => {
      const n = _e({
        props: s,
        ctx: e
      }, "trigger"), i = _e({
        props: s,
        ctx: e
      }, "overlay");
      return u(ot, {
        relative: `#${t}-toolbar-wrapper`,
        visible: s.visible,
        onChange: (l) => {
          s.onChange instanceof Function ? s.onChange(l) : e.emit("onChange", l);
        },
        overlay: i
      }, {
        default: () => [u("div", {
          class: `${d}-toolbar-item`,
          title: s.title || ""
        }, [n])]
      });
    };
  }
});
function Us(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !ni(s);
}
const qs = () => ({
  title: {
    type: String,
    default: ""
  },
  modalTitle: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean
  },
  width: {
    type: String,
    default: "auto"
  },
  height: {
    type: String,
    default: "auto"
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object]
  },
  onClick: {
    type: Function
  },
  onClose: {
    type: Function
  },
  /**
   * 显示全屏按钮
   */
  showAdjust: {
    type: Boolean,
    default: !1
  },
  isFullscreen: {
    type: Boolean,
    default: !1
  },
  onAdjust: {
    type: Function
  }
}), on = /* @__PURE__ */ ae({
  name: "ModalToolbar",
  props: qs(),
  emits: ["onClick", "onClose", "onAdjust"],
  setup(s, e) {
    return () => {
      const t = _e({
        props: s,
        ctx: e
      }, "trigger"), n = _e({
        props: s,
        ctx: e
      }, "default");
      return u(Kt, null, [u("div", {
        class: `${d}-toolbar-item`,
        title: s.title,
        onClick: () => {
          s.onClick instanceof Function ? s.onClick() : e.emit("onClick");
        }
      }, [t]), u(an, {
        width: s.width,
        height: s.height,
        title: s.modalTitle,
        visible: s.visible,
        onClose: () => {
          s.onClose instanceof Function ? s.onClose() : e.emit("onClose");
        },
        showAdjust: s.showAdjust,
        isFullscreen: s.isFullscreen,
        onAdjust: (i) => {
          s.onAdjust instanceof Function ? s.onAdjust(i) : e.emit("onAdjust", i);
        }
      }, Us(n) ? n : {
        default: () => [n]
      })]);
    };
  }
});
Ze.install = (s) => (s.component(Ze.name, Ze), s.component(sn.name, sn), s.component(ln.name, ln), s.component(Vt.name, Vt), s.component(on.name, on), s);
Ze.NormalToolbar = sn;
Ze.DropdownToolbar = ln;
Ze.MdCatalog = Vt;
Ze.ModalToolbar = on;
Ze.config = ai;
export {
  Ze as default
};
